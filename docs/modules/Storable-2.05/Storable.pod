=head1 名前

Storable - Perlデータ構造体の永続化

=head1 概要

 use Storable;
 store \%table, 'file';
 $hashref = retrieve('file');

 use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);

 # ネットワーク様式
 nstore \%table, 'file';
 $hashref = retrieve('file');   # There is NO nretrieve()

 # 既にオープンされているファイルへ格納し、取込ます
 store_fd \@array, \*STDOUT;
 nstore_fd \%table, \*STDOUT;
 $aryref = fd_retrieve(\*SOCKET);
 $hashref = fd_retrieve(\*SOCKET);

 # メモリへのシリアライズ
 $serialized = freeze \%table;
 %table_clone = %{ thaw($serialized) };

 # 深い（再帰的な）複写
 $cloneref = dclone($ref);

 # アドバイザリ・ロック
 use Storable qw(lock_store lock_nstore lock_retrieve)
 lock_store \%table, 'file';
 lock_nstore \%table, 'file';
 $hashref = lock_retrieve('file');

=head1 説明

Storableパッケージは、スカラー(SCALAR)、配列(ARRAY)、ハッシュ(HASH)、
オブジェクトのリファレンス(REF)を持ったPerlのデータ構造体を永続化します。
つまり簡単にディスクに格納し、後で取り込むことを可能にします。

格納するオブジェクトへのリファレンスとイメージが書き込まれるファイル名を
指定してC<store>を呼び出すという、通常の手続き的な方法で使うことが出来ます。

そのルーチンはI/O障害や他の内部エラーが発生するとC<undef>を返し、
そうでなければtrueを返します。重大なエラーはC<die>例外で伝えられます。

ディスクに格納されたデータを取り込むには、ファイル名を付けてC<retrieve>を
使います。そしてそのファイルに格納されたオブジェクトはメモリ上に再生成されます。
元になるオブジェクトへのI<リファレンス>が返されます。読込の途中で
I/Oエラーが発生すると、C<undef>が代わりに返されます。
他の重大なエラーの場合には、エラーがC<die>を通じて伝えられます。

格納が再帰的に行われるので、共通のデータの多くを共有しているオブジェクトへの
リファレンスたちを１つの配列またはハッシュテーブルに詰め込んでしまい、
そのオブジェクトを格納したいと思うかもしれません。この方法では、全体を
取り込んだときに、元々共有していたものを引き続き共有します。

ヘッダにちょっと手をいれると、C<store_fd>ルーチンを使って既に開いている
ファイル記述子に格納し、C<fd_retrieve>を通じてファイルから取り出すことが
できます。それらの名前はデフォルトではインポートされません。そのため、
これらのルーチンが必要であれば、明示的にインポートしなければいけません。
指定するファイル記述子は、取り込むつもりであれば読み込みread)で、
格納するつもりであれば書き込み(write)で、既に開かれていなければなりません。

    store_fd(\%table, *STDOUT) || die "can't store to stdout\n";
    $hashref = fd_retrieve(*STDIN);

複数のプラットホームで共有することを簡単にしたり、リモートに接続されている
ことが分かっているソケットに格納するときに、ネットワーク様式で格納することも
出来ます。呼び出すルーチンにはC<nstore>とC<nstore_fd>のように、頭にnetworkを
表すnが付きます。取り込むときはデータが正しく元に戻るので、取り込むのが
ネイティブからなのか、ネットワーク様式のデータからなのかを知る必要は
ありません。double（倍精度浮動小数点数型）の値も移植性が保証されるように
文字列化されます。ただし最後の桁の精度が若干失われる危険性があります。

C<retrieve_fd>を使うとき、オブジェクトは、対応するC<store_fd>毎、
1つのオブジェクト（つまり１つの再帰ツリー）を順番に取り込まれます。

さらにオブジェクト指向陣営寄りであれば、Storableを継承して、
C<store>をメソッドとして呼び出すことにより、あなたのオブジェクトを
直接格納することができます。格納されるツリーの元がblessされた
リファレンス（つまりオブジェクト）であれば、特別なケースになります。
そのため取込は、そのオブジェクトへのリファレンスを提供せず、
blessされたオブジェクト・リファレンスを提供します。
（そうでなければ、そのblessされたオブジェクトへのリファレンスを
取得することにでしょう）

=head1 メモリへの格納

Storableエンジンは後から取り込むために、Perlスカラーにデータを格納する
こともできます。これは主に複雑な構造体を安全で小さなメモリ空間に
固めるため(freeze)に使われます（構造体を固めると実際にはシリアライズも
されるので、他のプロセスにIPCを通じて送ることも潜在的には可能です）。
後で、そして多分どこか別のところで、Perlスカラを解凍(thaw)し、
元の複雑な構造体をメモリ上に再生成することができます。

驚いたことに、呼ばれるルーチンの名前はC<freeze>とC<thaw>といいます。
もし固めたスカラを他のマシンに送信したければ、代わりにC<nfreeze>を
ポータブルなイメージを取得してください。

オブジェクト構造を固め、すぐに解凍すると、実際には、その構造を深く
複写することを実現していることに注意して下さい：

    dclone(.) = thaw(freeze(.))

Storableは、中間のスカラを作成することなく、代わりに内部メモリ空間に
構造を固め、すぐに解凍するC<dclone>インターフェイスを提供しています。

=head1 アドバイザリ・ロック

C<lock_store>とC<lock_nstore>はC<store>とC<nstore>と同じです。ただし、
書き込む前に占有ロックを行います。同様にC<lock_retrieve>はC<retrieve>のように
動きます。しかし読み込む前に共有ロックを行います。

全てのアドバイザリ・ロックのスキームと同じように、保護はあなたが
システマティックにC<lock_store>とC<lock_retrieve>を使うときにだけ機能します。
もし他の部分がC<lock_retrieve>を使っているときに、あなたのアプリケーションの
ある部分がC<store>を使うと、何も保護されません。

アドバイザリ・ロックの内部はPerlのflock()ルーチンを使って実装されます。
もしあなたのシステムがflock()のいかなる形式もサポートしていなかったり、
あなたのファイルをNFS越しにファイルを共有しているのであれば、ファイル記述子ではなく
ファイルシステムのエントリを使ってロックするLockFile:Simpleのようなモジュールを
使って他の形式のロックを使いたいことでしょう。

=head1 スピード

スピードを上げるため、Storableの中核部分はCで書かれています。 Perl内部を操作するとき、
よりスピードを上げるためにカプセル化を犠牲にするという、特別な低レベルの最適化がな
されています。 

=head1 規範形式

通常StorableはハッシュをPerlが内部的に格納している順序で要素を格納します。つまり
疑似ランダムになります。もしC<$Storable::canonical>をC<TRUE>値に設定すると、
Storableはハッシュをそのキーの順に要素を格納します。これにより、データ構造体を
固められた形式で(または固められ圧縮され形式でさえ）比較することができるように
なります。これは複雑な問い合わせのための参照テーブルを作るのに便利でしょう。

規範様式(=Canonical)はネットワーク様式を意味していません。それらはまったく違う設定です。

=head1 コード・リファレンス

Storable バージョン 2.05から、コード(CODE)リファレンスがL<B::Deparse>の
助けを借りてシリアライズできます。この機能を有効にするためには、
C<$Storable::Deparse>をtrue値に設定してください。
デシリアライゼーションを有効にするためには、C<$Storable::Eval>がtrue値に
設定されていなければなりません。デシリアライゼーションがC<eval>を通して
行われることに注意してください。もしStorableファイルに悪意のあるデータが
入っていると危険です。C<$Storable::Eval>にC<eval>の代わりに使われる
サブルーチン・リファレンスを設定することができます。
コード(CODE)リファレンスのデシリアライゼーションについては、L<Safe>
コンポーネントを使っている下記の例をご覧ください。

=head1 将来への互換性

今回のStorableのリリースでは、Perlのより新しいバージョンで以前のPerlでは
サポートされていなかったデータをシリアライズするために使うことができます。
デフォルトではStorableは適切なことをしようとし、デシリアライズできない
データにぶつかったらC<croak()>します。しかしデフォルトは以下のように
変更することができます:

=over 4

=item utf8データ

Perl 5.6 は255よりも大きなコード値を持つUnicode文字のサポートが加わりました。
そしてPerl5.8では、ハッシュキーでのフルサポートを持ちます。Perlは内部的に、
これらの文字を持つ文字列をutf8を使ってエンコードします。Storableはutf8として、
それらをシリアライズします。デフォルトでは、より古いバージョンがそれが
表すことが出来ないutf8の値にぶつかると、それはC<croak()>します。Storableが
utf8をバイトの文字列としてエンコードされたものとしてデシリアライズするよう、
この動きを変更するためには、$C<Storable::drop_utf8>を何らかのC<TRUE>の値に
設定してください。これはデータが失われることになります。
というのもC<$drop_utf8>がtrueであると、もとのデータがUnicode文字列だったのか、
たまたまutf8として正しいバイトの並びだったのかが分からなくなってしまいます。

=item 限定ハッシュ

Perl 5.8は限定ハッシュ(restricted hash) のサポートを追加します。
それは与えられた集合にのみキーが制限され、値を読込のみにロックすることが
出来ます。デフォルトではそれらをサポートしていないperlではStorableが
限定ハッシュにぶつかると、それを通常のハッシュとしてデシリアライズします。
場所を保持するためのキーを全て黙って処分し、キーと値のロックを全て外します。
代わりにStorableにC<croak()>させるためには、C<$Storable::downgrade_restricted>を
C<FALSE>の値に設定してください。デフォルトの設定に戻すためには何らかのC<TRUE>値に
戻してください。

=item 将来のバージョンのStorableからのファイル

以前のStorableは、読んでいるStorableが知っているものより高い内部バージョンを
持ったファイルにぶつかるとすぐにcroakしました。内部バージョン番号は新しいデータ型
（限定ハッシュのような）がファイル形式の用語に加えられるたびに上がります。これは
より新しいStorableモジュールには、たとえ新しいデータ型を格納しなかったとしても、
古いStorableで読めるようなファイルを書く方法がないことを意味します。 

Storableのこのバージョンは、ファイルの中で、それが理解しないデータ型にぶつかるまで
croakしないという点で異なります。つまりこれは出力するものに注意を払えば、
新しいStorableモジュールで作られたファイルでも読むことが出来るということです。
これにより混在する環境でStorableをアップグレードすることが簡単になります。

C<$Storable::accept_future_minor>をC<FALSE>値にすることにより、即座にcroakする
というStorableの古い動きに戻すことが出来ます。

=back

これらの変数は関連する機能をサポートしている新しいPerlでは何の効果もありません。

=head1 エラー・レポート

Storableは"例外"パラダイムを使っています。それでは障害を回避しようとはしません:
何かよくないことが発生したら、呼び出した側の視点で例外が発生します
（L<Carp>とC<croak()>をご覧ください）。それらの例外を捕らえるためにはeval{}を
使ってください。

Storableがcroakするとき、C<Log::Agent>パッケージが利用できるのであれば、
そのC<logcroak()>ルーチンを経由してエラーを報告しようとします。

通常のエラーはstorable()やretrieve()にC<undef>を返すことにより報告されます。
そのようなエラーは通常I/Oのエラー（あるいはretrieveのさいにストリームが
切り捨てられたか）です。

=head1 上級者のみ

=head2 フック

全てのクラスで、そのクラスのインスタンスをシリアライズやデシリアライズの
処理の途中で呼ばれるフックを定義することもできます。それらのフックは
実行されるシリアライゼーションを実行する方法を再定義することが出来ます。
（そのため、対になるデシリアライゼーションも、そのように振舞わなければ
なりません）

前述の通り:

    dclone(.) = thaw(freeze(.))

フックについて述べたことはすべて、深いクローン作成にも当てはまります。
しかしフックには、その処理が単なるシリライゼーションなのかクローンなのかが
わかります。

このため、シリアライズ化のフックが呼び出されるとになります。

    dclone(.) <> thaw(freeze(.))

同期を取ることもできます。しかし誰か他の人が書いたクラスについて常に
当てはまるような保証はありません。さらに、そうすることによって得られるものは
あまりありません:シリアライズのフックは、あるオブジェクトの１つの属性を
保持することだけができます。それは、その同じオブジェクトの深い複写の間に起きる
こととは多分、違います。

以下にフックのインターフェイスを示します：

=over 4

=item C<STORABLE_freeze> I<obj>, I<cloning>

シリアライズ化フック。オブジェクトがシリアライズされるときに呼ばれます。
これは他のメソッドと同様に継承したり、クラスの中で再定義することができます。 

引数:I<obj>はシリアラズするオブジェクト、I<cloning>はdclone()の中であるか、
store()やfreeze()を経由した通常のシリアライゼーションかを示します。

戻り値:リスト C<($serialized, $ref1, $ref2, ...) >。 $serialized は、
使われるシリアライズされた形式、オプションの$ref1、$ref2などは、
Storableエンジンにシリアラズさせたい特別なリファレンスです。

デシリアライゼーションのときには、あなたは同じリスト(LIST)が与えられます。
しかし特別なリファレンスは全てデシリアライズされた構造体を示します。

B<最初に>フックがシリアライゼーションの流れの中でヒットしたとき、
あなたは空のリストを返すことができます。それはこのクラスのためのフックを、
それから先、捨てらるようStorableエンジンに合図し、このため元になっている
Perlデータのデフォルトのシリアライゼーションに戻ります。そのフックは次の
シリアライゼーションでは再び通常通り処理されます。

よく分からなければ、dclone()セマンティクスでも合理的になるよう、シリアライズの
フックは以下のようにするべきです：

    sub STORABLE_freeze {
        my ($self, $cloning) = @_;
        return if $cloning;         # 通常のデフォルトのシリアライゼーション
        ....
    }


=item C<STORABLE_thaw> I<obj>, I<cloning>, I<serialized>, ...

オブジェクトがデシリアライズされるときに呼ばれるデシリアライズ化フック。
しかし待ってください: もしデシリアライズしているのであれば、
オブジェクトはまだないのでは...？ 

違います：Storableエンジンはあなたのために空のものを生成します。
Eiffelをご存知であれば、C<STORABLE_thaw>は代替生成ルーチンとして
みることが出来ます。

つまり、フックは他のメソッドと同じように継承することができ、
C<obj>はこの特定のインスタンスのためのblessされたリファレンスになります。

その他の引数はC<STORABLE_freeze>を知っていれば慣れているでしょう:深い
クローン処理の一部であればI<cloning>はtrueになります。I<serialized>は
I<STORABLE_freeze>でエンジンに返したシリアライズされた文字列です。
そしてオプションのリファレンスのリストもあるかもしれません。
それはシリアル化のときにあなたが与えた順番で、デシリアライズされた
オブジェクトを指します（それらはStorableエンジンによって特別に扱われます）

Storableエンジンが何もSTORABLE_thawフック・ルーチンを見つけられなければ、
それは動的にパッケージを（blessされたパッケージ名を使って）requireすることにより
ロードしようとします。そして再び参照しようとします。もしこの時点で
フックが見つからなければ、エンジンはcroakします。この仕組は同じファイルで
いくつものクラスを定義しているとうまくいきません。しかしL<perlmod>が警告
するでしょう。

これらの情報を使って、どのようにI<obj>を作成するかは、あなた次第です。

戻り値:ありません。

=back

=head2 述語

述語（Predicates)はエクスポート可能ではありません。それらはStorableパッケージ名を
明示的に前につけて呼び出されなければなりません。

=over 4

=item C<Storable::last_op_in_netorder>

述語C<Storable::last_op_in_netorder()>は、最後のstoreあるいはretrieve操作のさい
ネットワーク・オーダーであったかを示します。もしこの使い方がわからなければ、
忘れてください。 

=item C<Storable::is_storing>

(STORABLE_freezeフックを経由して)store操作の中であればtrueを返します。 

=item C<Storable::is_retrieving>

(STORABLE_thawフックを経由して)retrieve操作の中であればtrueを返します。

=back

=head2 再帰

フックによってStorableエンジンに再帰的に戻ってくることが可能になります。
実際、フックは通常のPerlコードです。そしてStorableは、あるものをシリアライズ
したりデシリアライズするときに便利です。それならば、シリアライズされた
文字列を扱うために、それを使っていけないなんてことあるんでしょうか？

しかしいくつか覚えておかなければならないことがあります:

=over 4

=item *

もしfreeze()でシリアライズしようとしているものが、（例えば）フックの中で
シリアライズしようとしているオブジェクトを指しているとすると無限ループを
作ってしまうかもしれません。

=item *

オブジェクト間で共有される参照は共有されなくなります:オブジェクトAとCの両方が
同じオブジェクトBを参照しているとき、オブジェクトのリスト[A, C]をシリアライズし、
そしてAにfreeze(B)と書いてあるシリアライズのためのフックがあるなば、、
デシリアライズすると、[A', C']を取得し、A'はB'を参照します。しかしC'はB'の
深いクローンであるDを参照します。位相は保持されません。

=back

このためにC<STORABLE_freeze>はシリアライズするリファレンスのリストを提供させて
いるのです。エンジンは他のオブジェクトと同じコンテキストの中で、それらが
シリアライズされることを、そのため共有されたオブジェクトは共有されたままに
なることを保証します。

上記の[A, C]の例では、C<STORABLE_freeze>フックは以下のように返すことができます:

    ("something", $self->{B})

そしてB部分はエンジンによってシリアライズされます。C<STORABLE_thaw>では、
デシリアライズされたB'オブジェクトへのリファレンスを取得するでしょう。

このため再帰は通常は避けられるはずです。しかしそれでもサポートされています。

=head2 深いクローン作成

CPANから、深いクローン作成をネイティブに、つまりメモリ上に固め、
その結果を解凍することがなしに実装する新しいCloneモジュールが利用できます。
それは将来、Storableのdclone()を置き換えることを目標にしています。
しかし、実行される深いクローン作成の方法を再定義するためのStorableフックは、
まだサポートしていません。

=head1 Storableのmagic

そう、それはたくさん:-)。しかしより正確には、UNIXシステムではC<file>と
呼ばれるユーティリティがあります。それはその内容（通常はその先頭の数バイト）を
ベースにデータファイルを評価します。これが機能するためには、F<magic>と呼ばれる、
あるファイルがそのデータのI<特徴>（signature）について教える必要があります。
その構成設定ファイルがある場所はUNIXの好みに依存し、F</usr/share/misc/magic>や
F</etc/magic>のようなところによくあります。あなたのシステム管理者はF<magic>
ファイルを更新する必要があります。必要な特徴情報はStorable::show_file_magic()を
呼び出すことによりSTDOUTへ出力されます。C<file>ユーティリティ3.38以降の
GNUの実装には、他の種類のPerlファイルに加えて、Stoableファイルを評価するための
サポートが入っていると期待することができます。

=head1 使用例

Storableの使用法を示すコード・サンプルを以下に示します:

    use Storable qw(store retrieve freeze thaw dclone);

    %color = ('Blue' => 0.1, 'Red' => 0.8, 'Black' => 0, 'White' => 1);

    store(\%color, '/tmp/colors') or die "Can't store %a in /tmp/colors!\n";

    $colref = retrieve('/tmp/colors');
    die "Unable to retrieve from /tmp/colors!\n" unless defined $colref;
    printf "Blue is still %lf\n", $colref->{'Blue'};

    $colref2 = dclone(\%color);

    $str = freeze(\%color);
    printf "Serialization of %%color is %d bytes long.\n", length($str);
    $colref3 = thaw($str);

（私のマシンでの）出力結果：

    Blue is still 0.100000
    Serialization of %color is 102 bytes long.

Safeコンポーネント内でのコード(CODE)リファレンスのシリアライゼーションと
デシリアライゼーション:

    use Storable qw(freeze thaw);
    use Safe;
    use strict;
    my $safe = new Safe;
    # opcodeを"require"することを許すことは"use strict"を使う時には必須です
    $safe->permit(qw(:default require));
    local $Storable::Deparse = 1;
    local $Storable::Eval = sub { $safe->reval($_[0]) };
    my $serialized = freeze(sub { print "42\n" });
    my $code = thaw($serialized);
    $code->(); # prints 42

=head1 警告


ハッシュテーブルのキーとしてリファレンスを使っているならば、データを
取り出したときにガッカリするかもしれません。実際のところPerlは
ハッシュのキーとして使われているリファレンスを文字列化します。
もし後で他のリファレンスの文字列化を通じて（つまり元々、
ハッシュテーブルのなかに値を記録するためにキーとして使われたものと
同じリファレンスを使って）要素にアクセスしたければ、両方のリファレンスが
文字列化されたものが同じ文字列なので機能します。

しかし、C<store>とC<retieve>操作をまたぐと動きません。なぜなら取り込まれた
オブジェクトでのアドレス（文字列化されたリファレンスの一部です）が、
おそらく元のアドレスとは違っているからです。構造体の形は保持されますが、
このような隠された意味は保存されません。

問題となるプラットホームでは、Storable関数に渡す記述子にC<binmode>を
呼ぶようにして下さい。

データを規範形式で格納すると、大きなハッシュでは通常にデータを格納するのに
比べて非常に遅くなるかもしれません。というのも各ハッシュのためのキーを
保持するための一時的な配列を占有し、生き延びさせ、ソートし、解放しなければ
ならないためです。いくつかのテストでは格納のスピードが半減しました-- 
どれくらい遅くなるかはデータの複雑さに依存します。取込では遅くなることは
ありません。

=head1 バグ

GLOB, CODE, FORMLINE等は格納することが出来ません。これらの操作のための
意味をはっきり決めたら、それらを扱えるよう自由にStorableを拡張して下さい。

store関数は、C<$Strable::forgive_me>をなんらかのC<TRUE>値に設定しておかなければ、
それらのリファレンスに踏み込むとC<croak>します。その場合、警告で致命的な
メッセージが返され、代わりに意味のない文字列が格納されます。

C<$Storable::canonical>を設定すると、数値が文字列化される可能性から
同じものであると比較される固められた文字列を作り出さないかもしれません。
スカラーの文字列バージョンが存在するときには、それが格納される形式に
なります。このため、もし同じデータ構造の2回固める操作をする間に、
たまたま数値を文字列として使ってしまうと、違う結果になります。

double(倍精度浮動小数点）をネットワーク様式で格納するとき、その値は
テキストとして格納されます。しかし、nstore()/retrieve()の組み合わせに
正常に渡すことにより、無限や"数値ではない"ようなのような数値でない
浮動小数点を予想する必要はありません。

Storableは文字集合について知りませんし、気にもしません
（それは文字が8ビットよりも大きいかもしれないということは知っています）。
ホストとターゲット・システムでの文字コードの解釈における違いは、
すべてあなたの問題です。特にもしホストとターゲットが浮動小数点数の
テキスト形式で異なるコードポイントを使うのであれば、nstore()を使った
としても浮動小数点のデータをやりとりできないかもしれません。

C<Storable::drop_utf8>は鈍器のようなものです。それにはB<全ての>文字列を
utf8の並びとして返すか、utf8データを8ビットに変換しようとし、
変換に失敗したらC<croak()>する以外に機能はありません。

Storable 2.01より以前、格納時に符号付と符号なし整数での区別はつけられませんでした。
デフォルトではStorableは（もし持っていれば）スカラーを文字列表現を選びます。
そのため文字列や不動賞寸点数に変換されたことがない大きな符号なし整数を格納するとき
にだけ問題になります。言い換えれば、論理演算のような整数処理により作成され、
格納の前に何も文字列操作や算術コンテキストで使われなかった値です。

=head2 perl 5.6.0 と 5.6.1での64ビット・データ

このセクションは、64ビットinteger(デフォルトではありません）を
サポートするように構成設定されているUnixあるいはLinux上のperl5.6.0や5.6.1で
Storable2.20あるいはそれ以前によって出力された既存のデータを持っている場合に
のみ当てはまります。ソースから独自のperlを構築するためにConfigureを実行する
のではなく、既にコンパイルされているperlを取得したのであれば、
それはおそらく何も影響はないでしょう。そして、（あなたが疑問を持っていなければ）
ここで読むのを止めることが出来ます。Windowsでperlを使っていれば、何も影響は
ありません。

Storableは、Storableを構築したCコンパイラのさまざまなC言語の型の大きさが入った
ファイルヘッダを出力します。そして同じ（あるいは互換性のある）アーキテクチャでは
ないStorableによって書かれたファイルをロードすることを拒絶します。
ファイルの中のさまざまなフィールドはC言語の型の大きさによって与えられ、
そのため異なるアーキテクチャで書かれたファイルは互換性がないので、
このチェックとマシンのバイトオーダーについてのチェックは必要です。
これはスピードを向上させるために行われます（ネットワーク順で出力するとき、
全てのフィールドは標準の長さでかかれます。これは完全にネットワーク越える
ことを可能にしますが、読み込みと書込みはより時間がかかります）

Perl 5.6.x は、perlインタープリタが32ビット・システムで64ビットintegerを
格納できるスカラを可能にするCのC<long long>型を使う、オプションの構成設定の
機能を導入しました。しかしWindowsプラットホーム以外で
Perl構成設定システムがC構成設定ファイルを生成した方法や、
Storableがそのハンドラを生成する方法のために、
Storableは別にいくつかのデータをファイルに格納しているにも関わらず
perlが32あるいは64ビットintegerを使って出力したかは、
Storableファイル・ヘッダの内容に反映されません。

このため64ビットintegerでperlを実行しているStorableは32ビットperlによって
出力されたファイルからのヘッダを読み、データが実際には微妙に互換性のない
ものであると理解せず、格納されたintegerにぶつかると恐ろしい間違いを起こすでしょう
（おそらくはクラッシュしてしまいます）。これは設計上の失敗です。

Storableは現在はintegerの大きさについての情報を持ったファイル・ヘッダを
出力し、読み込むように変更されています。読み込まれた古いファイルが、32ビット
integerなのか64ビットなのかを判定することはできません（同じヘッダを持っています）。
そのため自動的に正しい後方互換性モードに自動的に移ることはできません。
そのためStorableはデフォルトでは、新しい正しい動きをになっています。

これが意味することは、UnixあるいはLinux上で64ビットintegerで構成設定された
perl 5.6.0や5.6.1で実行した Storable 1.xによって書かれたデータを持っている
のであれば、デフォルトではこのStorableはそれを読み込むことを拒絶し、
I<Byte order is not compatible>（バイト順に互換性がありません）というエラーに
なります。もしそのようなデータを持っているのであれば、
このStorableが古いヘッダを持っているファイルを読み書きできるよう、
C<$Storable::interwork_56_64bit>をtrue値に設定しなければなりません。
あなたデータやあなたが通信する古いperlを、Storableこの現行バージョンに
移すこともしなければなりません。

上記で記述された特定のperlの構成設定で書かれたデータを持っていなければ、
何もしなくてもいいですし、するべきでもありません。フラグを設定しないでください- 
同じように構成設定されたperlでのStorableが、それらをロードすることを拒絶する
だけでなく、違うように構成設定されたperlでのStorableが、それらをそれにとって
正しいものと信じてロードし、読み込んでいる途中で失敗したり、クラッシュしてしまいます。

=head1 謝辞

以下の方のバグ報告、提案、貢献に感謝いたします。 (時間順）：

    Jarkko Hietaniemi <jhi@iki.fi>
    Ulrich Pfeifer <pfeifer@charly.informatik.uni-dortmund.de>
    Benjamin A. Holzman <bah@ecnvantage.com>
    Andrew Ford <A.Ford@ford-mason.co.uk>
    Gisle Aas <gisle@aas.no>
    Jeff Gresham <gresham_jeffrey@jpmorgan.com>
    Murray Nesbitt <murray@activestate.com>
    Marc Lehmann <pcg@opengroup.org>
    Justin Banks <justinb@wamnet.com>
    Jarkko Hietaniemi <jhi@iki.fi> (AGAIN, as perl 5.7.0 Pumpkin!)
    Salvador Ortiz Garcia <sog@msg.com.mx>
    Dominic Dunlop <domo@computer.org>
    Erik Haugan <erik@solbors.no>

Benjamin Holzman はtieされた変数のサポートに貢献してくれました。
Andrew Ford はハッシュための標準様式に貢献してくれました。
そしてGisle Aas はPerlの内部についての私の誤解を修正し、タグを
つける代わりに単純にオブジェクトの数を数えることによって、
出力ストリームでの「タグ」の吐き出しを最適化してくれました。
（これによりバージョン0.6以降でバイナリでのStorableイメージの
互換性をなくすことになりました。しかし古いイメージもまだきちんと
理解されます。）Murray Nesbitt はStorableをスレッド・セーフにしてくれました。
Marc Lehmannはtieされている要素へのオーバーロードと参照のサポートを
追加してくれました。

=head1 作者

StorableはRaphael Manfredi <Raphael_Manfredi@pobox.com> によって作成されました。
現在、perl5-porters <perl5-porters@perl.org>　によってメンテナンスされています。

たとえRaphaelに送信するべき補足するものを持っていたとしても、障害、バグ修正、
コメント、苦情については私たちにメールしてください。どうか障害についてRaphaeに
メールしないでください。彼はもうStorableについて取り組んでいません。
そしてあなたのメッセージは彼が私たちに転送するまで遅れてしまいます。

=head1 参考資料

L<Clone>.

