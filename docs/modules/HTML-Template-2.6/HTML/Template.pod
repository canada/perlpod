=head1 NAME

=begin original

HTML::Template - Perl module to use HTML Templates from CGI scripts

=end original

HTML::Template - CGI スクリプトから HTML テンプレートを使うための Perl モジュール

=head1 SYNOPSIS

=begin original

First you make a template - this is just a normal HTML file with a few
extra tags, the simplest being <TMPL_VAR>

For example, test.tmpl:

=end original

最初にテンプレートを作ります - これは <TMPL_VAR> のようにとても簡単な、
2・3 の特殊なタグが入った普通の HTML ファイルです。

例えば、 test.tmpl:

  <html>
  <head><title>Test Template</title>
  <body>
  My Home Directory is <TMPL_VAR NAME=HOME>
  <p>
  My Path is set to <TMPL_VAR NAME=PATH>
  </body>
  </html>

=begin original

Now create a small CGI program:

=end original

そして小さな CGI プログラムを作ります:

  #!/usr/bin/perl -w
  use HTML::Template;

  # open the html template
  my $template = HTML::Template->new(filename => 'test.tmpl');

  # fill in some parameters
  $template->param(HOME => $ENV{HOME});
  $template->param(PATH => $ENV{PATH});

  # send the obligatory Content-Type and print the template output
  print "Content-Type: text/html\n\n", $template->output;

=begin original

If all is well in the universe this should show something like this in
your browser when visiting the CGI:

=end original

これですべてがうまくいっていれば、ブラウザでそのCGIにいくと、
以下のようなものが表示されます:

  My Home Directory is /home/some/directory
  My Path is set to /bin;/usr/bin

=head1 DESCRIPTION

=begin original

This module attempts to make using HTML templates simple and natural.
It extends standard HTML with a few new HTML-esque tags - <TMPL_VAR>,
<TMPL_LOOP>, <TMPL_INCLUDE>, <TMPL_IF>, <TMPL_ELSE> and <TMPL_UNLESS>.
The file written with HTML and these new tags is called a template.
It is usually saved separate from your script - possibly even created
by someone else!  Using this module you fill in the values for the
variables, loops and branches declared in the template.  This allows
you to separate design - the HTML - from the data, which you generate
in the Perl script.

=end original

このモジュールは HTML テンプレートを使うことを簡単に、自然にしようとします。
これは標準の HTML をいくつかの新しいHTML風のタグ - <TMPL_VAR>, <TMPL_LOOP>, 
<TMPL_INCLUDE>, <TMPL_IF>, <TMPL_ELSE>, <TMPL_UNLESS> で拡張します。
HTML とこれらの新しいタグで書かれたファイルはテンプレートと呼ばれます。
これは通常スクリプトとは別に保存されます -
もしかしたら他の誰かによって作成されることさえあるかもしれません!
このモジュールを使って、変数のための値を埋めたり、テンプレートで
宣言されたループや分岐をおこないます。
これにより Perl スクリプトで作成されるデータからデザイン - HTML - を
分けることが出来ます。

=begin original

This module is licensed under the GPL.  See the LICENSE section
below for more details.

=end original

このモジュールは GPL の元でライセンスされます。
詳細についてはライセンス(LICENSE)・セクションをご覧下さい。

=head1 TUTORIAL

(チュートリアル)

=begin original

If you're new to HTML::Template, I suggest you start with the
introductory article available on the HTML::Template website:

=end original

もしあなたが HTML::Template を使うのが初めてなら、
HTML::Template ウェブサイトにある紹介文書から始めることを
お勧めします。

   http://html-template.sourceforge.net

=head1 MOTIVATION

(動機)

=begin original

It is true that there are a number of packages out there to do HTML
templates.  On the one hand you have things like HTML::Embperl which
allows you freely mix Perl with HTML.  On the other hand lie
home-grown variable substitution solutions.  Hopefully the module can
find a place between the two.

=end original

HTML テンプレートを行っているパッケージがたくさんあることは事実です。
HTML::Embperl のように HTML に自由に Perl を混ぜることを許すものもあります。
さらに一方では自家製の変数置換による解決法もあります。
このモジュールが、それら 2 つの間に居場所を見つけられることを望んでいます。

=begin original

One advantage of this module over a full HTML::Embperl-esque solution
is that it enforces an important divide - design and programming.  By
limiting the programmer to just using simple variables and loops in
the HTML, the template remains accessible to designers and other
non-perl people.  The use of HTML-esque syntax goes further to make
the format understandable to others.  In the future this similarity
could be used to extend existing HTML editors/analyzers to support
HTML::Template.

=end original

このモジュールのフルの HTML::Embperl のような解決法に対する有利な点の 1 つは、
重要な分割 - デザインとプログラミング - を強制することです。
プログラマには簡単な変数とループを HTML で使うことに限定し、
テンプレートはデザイナやその他の perl を知らない人たちからも
アクセスできるようになっています。
HTML のような文法を使っているので、
他のものと比べてそのフォーマットを非常に理解しやくなっています。
似ていることから、将来的に既存の HTML エディタ／アナライザが
HTML::Template をサポートするように拡張しやすくなっています。

=begin original

An advantage of this module over home-grown tag-replacement schemes is
the support for loops.  In my work I am often called on to produce
tables of data in html.  Producing them using simplistic HTML
templates results in CGIs containing lots of HTML since the HTML
itself cannot represent loops.  The introduction of loop statements in
the HTML simplifies this situation considerably.  The designer can
layout a single row and the programmer can fill it in as many times as
necessary - all they must agree on is the parameter names.

=end original

自家製のタグ置換法に対する有利な点はループをサポートしていることです。
私は仕事の中で、HTML でテーブルを作成するためによく呼び出しています。
HTML そのものはループを表すことが出来ないので、
簡単に割り切りすぎた HTML を使うと CGI の中に大量の HTML が入ってしまいます。
HTML にループ・ステートメントを導入するとこの状況をとても簡単にします。
デザイナは 1 つの行をレイアウトし、
プログラマは必要に合わせて何回も埋めることが出来ます - 
それらはすべてパラメータ名について合意しておく必要があります。

=begin original

For all that, I think the best thing about this module is that it does
just one thing and it does it quickly and carefully.  It doesn't try
to replace Perl and HTML, it just augments them to interact a little
better.  And it's pretty fast.

=end original

なにより、私がこのモジュールについて最もよいことだと思っていることは、
それは 1 つのことしかしませんし、それを速く、注意深く行います。
それは Perl や HTML を置き換えようとはしません。
相互への影響をちょっとだけ増やすだけです。そしてそれはかなり速いのです。

=head1 THE TAGS

(タグ)

=head2 TMPL_VAR

  <TMPL_VAR NAME="PARAMETER_NAME">

=begin original

The <TMPL_VAR> tag is very simple.  For each <TMPL_VAR> tag in the
template you call $template->param(PARAMETER_NAME => "VALUE").  When
the template is output the <TMPL_VAR> is replaced with the VALUE text
you specified.  If you don't set a parameter it just gets skipped in
the output.

=end original

<TMPL_VAR> タグはとても簡単です。
テンプレートの中の各 <TMPL_VAR> タグのために、
$template->param(PARAMETER_NAME => "VALUE") を呼びます。
テンプレートが出力されるとき <TMPL_VAR> は指定された VALUE の文字列で
置きかえられます。パラメータに値を設定しなければ、出力の際に飛ばされます。

=begin original

Optionally you can use the "ESCAPE=HTML" option in the tag to indicate
that you want the value to be HTML-escaped before being returned from
output (the old ESCAPE=1 syntax is still supported).  This means that
the ", <, >, and & characters get translated into &quot;, &lt;, &gt;
and &amp; respectively.  This is useful when you want to use a
TMPL_VAR in a context where those characters would cause trouble.
Example:

=end original

オプションで、出力から戻される前に値が HTML-エスケープしたいことを示すために、
タグの中で"ESCAPE=HTML"オプションを使うことが出来ます
(昔の ESCAPE=1 という書き方もまだサポートされています)。
つまり ", <, >, & といった文字は、&quot;, &lt;, &gt;, &amp; に
それぞれ変換されます。
それらの文字がトラブルを起こしかねない場所で TMPL_VAR を使いたいときに便利です。

   <input name=param type=text value="<TMPL_VAR NAME="PARAM">">

=begin original

If you called param() with a value like sam"my you'll get in trouble
with HTML's idea of a double-quote.  On the other hand, if you use
ESCAPE=HTML, like this:

=end original

もし'sam"my'のような値でparam()を呼び出すと、
ダブルクオートについての HTML の考え方のせいで厄介なことになります。
対して以下のように ESCAPE=HTML を使うと：

   <input name=param type=text value="<TMPL_VAR ESCAPE=HTML NAME="PARAM">">

=begin original

You'll get what you wanted no matter what value happens to be passed in for
param.  You can also write ESCAPE="HTML", ESCAPE='HTML' and ESCAPE='1'.
Substitute a 0 for the HTML and you turn off escaping, which is the default
anyway.

=end original

param に渡された値に関わらず、欲しいものを手に入れることが出来ます。
ESCAPE="HTML", ESCAPE='HTML', ESCAPE='1' とも書けます。
HTML を 0 で置換すると、エスケープをオフとし、それはデフォルトです。

=begin original

There is also the "ESCAPE=URL" option which may be used for VARs that
populate a URL.  It will do URL escaping, like replacing ' ' with '+'
and '/' with '%2F'.

=end original

"ESCAPE=URL" オプションもあります。
これは URL に適した VAR に使うことが出来ます。
それは' 'を + に、'/' を '%2F' に置きかえるといった、
URL エスケープをおこないます。

=begin original

You can assign a default value to a variable with the DEFAULT
attribute.  For example, this will output "the devil gave me a taco"
if the "who" variable is not set.

=end original

DEFAULT 属性を使って変数のデフォルト値を設定することもできます。
例えば、"who" 変数が設定されていないときは "the devil gave me a taco" と
表示させるためには、以下のようにします。

  The <TMPL_VAR NAME=WHO DEFAULT=devil> gave me a taco.

=head2 TMPL_LOOP

  <TMPL_LOOP NAME="LOOP_NAME"> ... </TMPL_LOOP>

=begin original

The <TMPL_LOOP> tag is a bit more complicated than <TMPL_VAR>.  The
<TMPL_LOOP> tag allows you to delimit a section of text and give it a
name.  Inside this named loop you place <TMPL_VAR>s.  Now you pass to
param() a list (an array ref) of parameter assignments (hash refs) for
this loop.  The loop iterates over the list and produces output from
the text block for each pass.  Unset parameters are skipped.  Here's
an example

=end original

<TMPL_LOOP> タグは <TMPL_VAR> よりちょっとだけ複雑です。
<TMPL_LOOP> タグはテキストのセクションを区切り、
名前をつけることを可能とします。
この名前つきループの内側に <TMPL_VAR> を置きます。
そしてこのループでパラメータに代入する(ハッシュ・リファレンスの
param() にリスト(配列リファレンス)を渡します。
ループはリストの間、繰り返され、
渡す度にテキスト・ブロックからの出力を作成します。
設定されないパラメータは飛ばされます。以下に例を示します:

 In the template:

   <TMPL_LOOP NAME=EMPLOYEE_INFO>
      Name: <TMPL_VAR NAME=NAME> <br>
      Job:  <TMPL_VAR NAME=JOB>  <p>
   </TMPL_LOOP>


 In the script:

   $template->param(EMPLOYEE_INFO => [ 
                                       { name => 'Sam', job => 'programmer' },
                                       { name => 'Steve', job => 'soda jerk' },
                                     ]
                   );
   print $template->output();

  
 The output in a browser:

   Name: Sam
   Job: programmer

   Name: Steve
   Job: soda jerk

=begin original

As you can see above the <TMPL_LOOP> takes a list of variable
assignments and then iterates over the loop body producing output.

=end original

上記にあるように <TMPL_LOOP> は変数代入のリストを取り、
出力を作成するループ本体を繰り返します。

=begin original

Often you'll want to generate a <TMPL_LOOP>'s contents
programmatically.  Here's an example of how this can be done (many
other ways are possible!):

=end original

しばしば、<TMPL_LOOP> の内容をプログラム的に作成したいことでしょう。
以下にそれをどのように行うかの例を示します
(他にもいろんな方法が可能です!):

   # a couple of arrays of data to put in a loop:
   my @words = qw(I Am Cool);
   my @numbers = qw(1 2 3);

   my @loop_data = ();  # initialize an array to hold your loop

   while (@words and @numbers) {
     my %row_data;  # get a fresh hash for the row data

     # fill in this row
     $row_data{WORD} = shift @words;
     $row_data{NUMBER} = shift @numbers;
 
     # the crucial step - push a reference to this row into the loop!
     push(@loop_data, \%row_data);
   }

   # finally, assign the loop data to the loop param, again with a
   # reference:
   $template->param(THIS_LOOP => \@loop_data);

=begin original

The above example would work with a template like:

=end original

上記の例は以下のようなテンプレートで機能します:

   <TMPL_LOOP NAME="THIS_LOOP">
      Word: <TMPL_VAR NAME="WORD">     <br>
      Number: <TMPL_VAR NAME="NUMBER"> <p>
   </TMPL_LOOP>

=begin original

It would produce output like:

=end original

それは以下のような出力を作成します:

   Word: I
   Number: 1

   Word: Am
   Number: 2

   Word: Cool
   Number: 3

=begin original

<TMPL_LOOP>s within <TMPL_LOOP>s are fine and work as you would
expect.  If the syntax for the param() call has you stumped, here's an
example of a param call with one nested loop:

=end original

<TMPL_LOOP> の中の <TMPL_LOOP> は問題なく、期待通りに機能します。
param() 呼び出しのための文法が悩ましているのであれば、
1 つのネストしたループでの param 呼び出しの例を以下に示します：

  $template->param(LOOP => [
                            { name => 'Bobby',
                              nicknames => [
                                            { name => 'the big bad wolf' }, 
                                            { name => 'He-Man' },
                                           ],
                            },
                           ],
                  );

=begin original

Basically, each <TMPL_LOOP> gets an array reference.  Inside the array
are any number of hash references.  These hashes contain the
name=>value pairs for a single pass over the loop template.  

=end original

基本的に、各 <TMPL_LOOP> は 1 つの配列リファレンスを取得します。
配列の内側にはハッシュ・リファレンスをいくつでも入れることが出来ます。
これらのハッシュにはループ・テンプレートに 1 つずつ渡す名前 => 値の組が
入っています。

=begin original

Inside a <TMPL_LOOP>, the only variables that are usable are the ones
from the <TMPL_LOOP>.  The variables in the outer blocks are not
visible within a template loop.  For the computer-science geeks among
you, a <TMPL_LOOP> introduces a new scope much like a perl subroutine
call.  If you want your variables to be global you can use
'global_vars' option to new() described below.

=end original

<TMPL_LOOP> の内側では、<TMPL_LOOP> から利用できる変数だけが入ります。
外側のブロックの変数はテンプレート・ループの中では見えません。
コンピュータ・サイエンス的にいえば、
<TMPL_LOOP> は perl サブルーチンのように新しいスコープを導入したのです。
変数をグローバルにしたければ、
下記で説明する new() へ'global_vars'を使うことが出来ます。

=head2 TMPL_INCLUDE

  <TMPL_INCLUDE NAME="filename.tmpl">

=begin original

This tag includes a template directly into the current template at the
point where the tag is found.  The included template contents are used
exactly as if its contents were physically included in the master
template.

=end original

このタグは現在のテンプレートのタグのある場所に直接テンプレートを入れます。
入れられるテンプレートの内容は、その内容がマスター・テンプレートに
物理的に入れられているのとまったく同じように使われます。

=begin original

The file specified can be an absolute path (beginning with a '/' under
Unix, for example).  If it isn't absolute, the path to the enclosing
file is tried first.  After that the path in the environment variable
HTML_TEMPLATE_ROOT is tried, if it exists.  Next, the "path" option is
consulted, first as-is and then with HTML_TEMPLATE_ROOT prepended if
available.  As a final attempt, the filename is passed to open()
directly.  See below for more information on HTML_TEMPLATE_ROOT and
the "path" option to new().

=end original

ファイルは絶対パス(例えばUnix では '/'から始まる)で指定することが出来ます。
もし絶対パスでなければ、囲まれたファイルへのパスが最初に試されます。
その後、もしあれば環境変数 HTML_TEMPLAGE_ROOT でのパスが試されます。
次に "path" オプションが試されます。まずはそのまま、
その後 HTML_TEMPLATE_ROOT が利用可能ならそれを前につけて試されます。
最後にファイル名が直接 open() に渡されます。
HTML_TEMPLATE_ROOT と new() への "path" オプションについての詳細は
下記をご覧下さい。

=begin original

As a protection against infinitly recursive includes, an arbitary
limit of 10 levels deep is imposed.  You can alter this limit with the
"max_includes" option.  See the entry for the "max_includes" option
below for more details.

=end original

無限に再帰するインクルードを避けるため、
深さは 10 レベルに制限されています。
この制限は"max_includes"オプションで変えることが出来ます。
"max_includes"オプションの詳細については、下記をご覧下さい。

=head2 TMPL_IF

  <TMPL_IF NAME="PARAMETER_NAME"> ... </TMPL_IF>

=begin original

The <TMPL_IF> tag allows you to include or not include a block of the
template based on the value of a given parameter name.  If the
parameter is given a value that is true for Perl - like '1' - then the
block is included in the output.  If it is not defined, or given a
false value - like '0' - then it is skipped.  The parameters are
specified the same way as with TMPL_VAR.

=end original

<TMPL_IF> タグは与えられたパラメータ名の値に基づいて、
テンプレートのブロックを入れるか入れないかを可能にします。
与えられたパラメータの値が Perl での true - '1' のような - であれば、
ブロックは出力に入れられます。未定義であるか、
false の値 - '0' のような - であれば、飛ばされます。
パラメータは TMPL_VAR と同じ方法で指定されます。

=begin original

Example Template:

=end original

例のテンプレート：

   <TMPL_IF NAME="BOOL">
     Some text that only gets displayed if BOOL is true!
   </TMPL_IF>

=begin original

Now if you call $template->param(BOOL => 1) then the above block will
be included by output. 

=end original

そこで $template->param(BOOL => 1) を呼び出すと、
上記のブロックが出力に入ります。

=begin original

<TMPL_IF> </TMPL_IF> blocks can include any valid HTML::Template
construct - VARs and LOOPs and other IF/ELSE blocks.  Note, however,
that intersecting a <TMPL_IF> and a <TMPL_LOOP> is invalid.

=end original

<TMPL_IF> </TMPL_IF> ブロックは正しい HTML::Template構造であれば -
VAR, LOOP そして他の IF/ELSE ブロック - どこにでもいれることができます。
しかし <TMPL_IF> と <TMPL_LOOP> が交差するのは正しくないことに注意してください。

   Not going to work:
   <TMPL_IF BOOL>
      <TMPL_LOOP SOME_LOOP>
   </TMPL_IF>
      </TMPL_LOOP>

=begin original

If the name of a TMPL_LOOP is used in a TMPL_IF, the IF block will
output if the loop has at least one row.  Example:

=end original

もし TMPL_LOOP の名前が TMPL_IF で使われていれば、
もし LOOP が 1 つでも行を持っていれば、IF ブロックは出力します。例えば：

  <TMPL_IF LOOP_ONE>
    This will output if the loop is not empty.
  </TMPL_IF>

  <TMPL_LOOP LOOP_ONE>
    ....
  </TMPL_LOOP>

=begin original

WARNING: Much of the benefit of HTML::Template is in decoupling your
Perl and HTML.  If you introduce numerous cases where you have
TMPL_IFs and matching Perl if()s, you will create a maintenance
problem in keeping the two synchronized.  I suggest you adopt the
practice of only using TMPL_IF if you can do so without requiring a
matching if() in your Perl code.

=end original

警告: HTML::Template の大きな利点は Perl と HTML を分けることです。
もし TMPL_IF のあるところでたくさんのケースを導入し、
それが Perl の if() に対応しているのであれば、
2 つの同期を保持するためのメンテナンス上の問題をおこすでしょう。
Perl のコードでの if() に対応することを要求せずにそうできるときにのみ、
TMPL_IF を実際に利用するように提案します。

=head2 TMPL_ELSE

  <TMPL_IF NAME="PARAMETER_NAME"> ... <TMPL_ELSE> ... </TMPL_IF>

=begin original

You can include an alternate block in your TMPL_IF block by using
TMPL_ELSE.  NOTE: You still end the block with </TMPL_IF>, not
</TMPL_ELSE>!

=end original

TMPL_ELSE を使うことにより TEMPL_IF ブロックの代りのブロックを
入れることが出来ます。
注意:ブロックを終わらせるのは、
まだ </TMPL_IF> であって </TMPL_ELSE> ではありません！ 

   Example:

   <TMPL_IF BOOL>
     Some text that is included only if BOOL is true
   <TMPL_ELSE>
     Some text that is included only if BOOL is false
   </TMPL_IF>

=head2 TMPL_UNLESS

  <TMPL_UNLESS NAME="PARAMETER_NAME"> ... </TMPL_UNLESS>

=begin original

This tag is the opposite of <TMPL_IF>.  The block is output if the
CONTROL_PARAMETER is set false or not defined.  You can use
<TMPL_ELSE> with <TMPL_UNLESS> just as you can with <TMPL_IF>.

=end original

このタグは <TMPL_IF> の反対です。
CONTROL_PARAMETER が false に設定されているか未定義であると
ブロックが出力されます。
<TMPL_ELSE> を <TMPL_IF> とまったく同じように <TMPL_UNLESS> と
一緒に使うことも出来ます。

  Example:

  <TMPL_UNLESS BOOL>
    Some text that is output only if BOOL is FALSE.
  <TMPL_ELSE>
    Some text that is output only if BOOL is TRUE.
  </TMPL_UNLESS>

=begin original

If the name of a TMPL_LOOP is used in a TMPL_UNLESS, the UNLESS block
output if the loop has zero rows.

=end original

TMPL_UNLESS で TMPL_LOOP の名前が使われていれば、
UNLESS ブロックはループに行がなければ出力されます。

  <TMPL_UNLESS LOOP_ONE>
    This will output if the loop is empty.
  </TMPL_UNLESS>
  
  <TMPL_LOOP LOOP_ONE>
    ....
  </TMPL_LOOP>

=head2 NOTES

(注意)

=begin original

HTML::Template's tags are meant to mimic normal HTML tags.  However,
they are allowed to "break the rules".  Something like:

=end original

HTML::Template のタグが HTML のように見えます。
しかし、"ルール破り"が認められています。以下のように:

   <img src="<TMPL_VAR IMAGE_SRC>">

=begin original

is not really valid HTML, but it is a perfectly valid use and will
work as planned.

=end original

これは本当は適切な HTML ではなりません。
しかしこれは完璧に正しい使い方ですし、予定通りに機能します。

=begin original

The "NAME=" in the tag is optional, although for extensibility's sake I
recommend using it.  Example - "<TMPL_LOOP LOOP_NAME>" is acceptable.

=end original

タグでの "NAME=" はオプションですが、
拡張性の点から私はそれを使う事を推奨します。
例えば - "<TMPL_LOOP LOOP_NAME>" は受け入れられます。

=begin original

If you're a fanatic about valid HTML and would like your templates
to conform to valid HTML syntax, you may optionally type template tags
in the form of HTML comments. This may be of use to HTML authors who
would like to validate their templates' HTML syntax prior to
HTML::Template processing, or who use DTD-savvy editing tools.

=end original

適切な HTML へに熱心で、テンプレートが HTML 文法に適切であるように
従わせたいのであれば、HTML コメントの形式のなかにテンプレートを
入力することが出来ます。
これは、HTML::Template 処理の前にテンプレートの HTML 文法が
正しいかどうかをチェックしたい HTML 作者や
DTD-savvy 編集ツールを使っている人には便利でしょう。

  <!-- TMPL_VAR NAME=PARAM1 -->

=begin original

In order to realize a dramatic savings in bandwidth, the standard
(non-comment) tags will be used throughout this documentation.

=end original

劇的な帯域の節約を実現するために、
このドキュメントの全てで標準(コメントでない)タグが使われます。

=head1 METHODS

(メソッド)

=head2 new()

=begin original

Call new() to create a new Template object:

=end original

新しい Template オブジェクトを作るには new() を呼び出します：

  my $template = HTML::Template->new( filename => 'file.tmpl', 
                                      option => 'value' 
                                    );

=begin original

You must call new() with at least one name => value pair specifying how
to access the template text.  You can use "filename => 'file.tmpl'" to
specify a filename to be opened as the template.  Alternately you can
use:

=end original

テンプレート・テキストにどのようにアクセスするかを指定する、
少なくとも 1 つの名前 => 値の組を指定して new() を
呼び出さなければなりません。
"filename=>'file.tmpl'" を使って、
テンプレートとしてオープンされるファイル名を指定することができます。
代りに以下のようにすることもできます：

  my $t = HTML::Template->new( scalarref => $ref_to_template_text, 
                               option => 'value' 
                             );

=begin original

and

=end original

と

  my $t = HTML::Template->new( arrayref => $ref_to_array_of_lines , 
                               option => 'value' 
                             );


=begin original

These initialize the template from in-memory resources.  In almost
every case you'll want to use the filename parameter.  If you're
worried about all the disk access from reading a template file just
use mod_perl and the cache option detailed below.

=end original

これらはメモリ上の資源からテンプレートを初期化します。
ほとんどの場合、filename パラメータを使いたいでしょう。
もしテンプレート・ファイルからの読み込みの
すべてのディスク・アクセスについて心配であれば、
mod_perl と以下に説明する cache オプションを使ってください。

=begin original

You can also read the template from an already opened filehandle,
either traditionally as a glob or as a FileHandle:

=end original

テンプレートを既にオープンしているファイルハンドルから
読み込むこともできます。伝統的なグロブとファイルハンドルの
両方が使えます。

  my $t = HTML::Template->new( filehandle => *FH, option => 'value');

=begin original

The four new() calling methods can also be accessed as below, if you
prefer.

=end original

お好みであれば、4 つの new() 呼び出しメソッドは
以下のようにもアクセスされます:

  my $t = HTML::Template->new_file('file.tmpl', option => 'value');

  my $t = HTML::Template->new_scalar_ref($ref_to_template_text, 
                                        option => 'value');

  my $t = HTML::Template->new_array_ref($ref_to_array_of_lines, 
                                       option => 'value');

  my $t = HTML::Template->new_filehandle($fh, 
                                       option => 'value');

=begin original

And as a final option, for those that might prefer it, you can call new as:

=end original

そして最後のオプションとして、以下のようにも呼び出すことが出来ます:

  my $t = HTML::Template->new(type => 'filename', 
                              source => 'file.tmpl');

=begin original

Which works for all three of the source types.

=end original

これはソースタイプの 3 つ全てに機能します。

=begin original

If the environment variable HTML_TEMPLATE_ROOT is set and your
filename doesn't begin with /, then the path will be relative to the
value of $HTML_TEMPLATE_ROOT.  Example - if the environment variable
HTML_TEMPLATE_ROOT is set to "/home/sam" and I call
HTML::Template->new() with filename set to "sam.tmpl", the
HTML::Template will try to open "/home/sam/sam.tmpl" to access the
template file.  You can also affect the search path for files with the
"path" option to new() - see below for more information.

=end original

環境変数 HTML_TEMPLATE_ROOT が設定され、filename が / で始まらなければ、
パスは $HTML_TEMPLATE_ROOT からの相対パスでしょう。
例えば - 環境変数 HTML_TEMPLATE_ROOT が "/home/sam" に設定され、
HTML::Template->new() をファイル名を "sam.tmpl" に設定して呼び出すと、
HTML::Template はテンプレート・ファイルにアクセスするために
"/home/sam/sam.tmpl" をオープンしようとします。
また new() への "path" オプションで検索パスに影響を与えることも出来ます -
詳細な情報については以下をご覧下さい。

=begin original

You can modify the Template object's behavior with new.  These options
are available:

=end original

Templarte オブジェクトの動きを new で変更することが出来ます。
以下のオプションが利用できます:

=over 4

=item Error Detection Options

(エラー検出オプション)

=over 4 

=item *

=begin original

die_on_bad_params - if set to 0 the module will let you call
$template->param(param_name => 'value') even if 'param_name' doesn't
exist in the template body.  Defaults to 1.

=end original

die_on_bad_params - 0 に設定すると、
モジュールはたとえ param_name がテンプレート本体になくても、
$template->param(param_name => 'value') を呼び出すことができます。
デフォルトは 1 です。

=item *

=begin original

strict - if set to 0 the module will allow things that look like they
might be TMPL_* tags to get by without dieing.  Example:

=end original

strict - 0 に設定すると、モジュールは die することなく、
TMPL_* タグのように見えるようなものも許します。
例えば:

   <TMPL_HUH NAME=ZUH>

=begin original

Would normally cause an error, but if you call new with strict => 0,
HTML::Template will ignore it.  Defaults to 1.

=end original

は通常エラーになりますが、strict=>0 で new を呼び出すと、
HTML::Template はそれを無視します。デフォルトは 1 です。

=item *

=begin original

vanguard_compatibility_mode - if set to 1 the module will expect to
see <TMPL_VAR>s that look like %NAME% in addition to the standard
syntax.  Also sets die_on_bad_params => 0.  If you're not at Vanguard
Media trying to use an old format template don't worry about this one.
Defaults to 0.

=end original

vanguard_compatibility_mode - 1 に設定すると、
モジュールは通常の書き方に加えて、
%NAME% のような <TMPL_VARS> を見ることを予定します。
die_on_bad_params => 0 も設定してください。
Vanguard Media にいて古いフォーマットのテンプレートを
使おうとしているのでなければ、これを気にすることはありません。
デフォルトは 0 です。

=back

=item Caching Options

(キャッシュオプション)

=over 4

=item *

=begin original

cache - if set to 1 the module will cache in memory the parsed
templates based on the filename parameter and modification date of the
file.  This only applies to templates opened with the filename
parameter specified, not scalarref or arrayref templates.  Caching
also looks at the modification times of any files included using
<TMPL_INCLUDE> tags, but again, only if the template is opened with
filename parameter.  

=end original

cache - 1 に設定すると、モジュールは filename パラメータと
ファイルの変更日付を元に解析されたテンプレートを
メモリ上にキャッシュします。
これは scalarref や arrayref テンプレートではなく、
filename パラメータでオープンされたテンプレートにのみ適用されます。
モジュールは <TMPL_INCLUDE> タグを使って入れられている
すべてのファイルの変更日付も見ますが、この動作もまた、
filename パラメータでテンプレートがオープンされたときのみです。

=begin original

This is mainly of use in a persistent environment like
Apache/mod_perl.  It has absolutely no benefit in a normal CGI
environment since the script is unloaded from memory after every
request.  For a cache that does work for normal CGIs see the
'shared_cache' option below.

=end original

これは主に Apache/mod_perl のように永続する環境でのみ使われます。
各リクエストの後にスクリプトがメモリからアンロードされるので、
通常の CGI 環境ではまったく利点はありません。
通常の CGI のために機能するキャッシュについては、
以下の 'shared_cache' オプションをご覧下さい。

=begin original

Note that different new() parameter settings do not cause a cache
refresh, only a change in the modification time of the template will
trigger a cache refresh.  For most usages this is fine.  My simplistic
testing shows that using cache yields a 90% performance increase under
mod_perl.  Cache defaults to 0.

=end original

異なる new() パラメータ設定はキャッシュのリフレッシュを引き起こしません、
テンプレートの変更時刻での変更だけがキャッシュ・リフレッシュを引き起こします。
ほとんどの使い方ではこれはうまくいきます。
私が簡単にテストしたところ、キャッシュを使うと、
mod_perl の下で 90% のパフォーマンスの上昇がありました。
cache のデフォルトは 0 です。

=item *

=begin original

shared_cache - if set to 1 the module will store its cache in shared
memory using the IPC::SharedCache module (available from CPAN).  The
effect of this will be to maintain a single shared copy of each parsed
template for all instances of HTML::Template to use.  This can be a
significant reduction in memory usage in a multiple server
environment.  As an example, on one of our systems we use 4MB of
template cache and maintain 25 httpd processes - shared_cache results
in saving almost 100MB!  Of course, some reduction in speed versus
normal caching is to be expected.  Another difference between normal
caching and shared_cache is that shared_cache will work in a CGI
environment - normal caching is only useful in a persistent
environment like Apache/mod_perl.

=end original

shared_cache - 1 に設定すると、モジュールは(CPAN から利用できる)
IPC::SharedCache モジュールを使って共有メモリに格納します。
この影響は、1 つの各解析されたすべての TML::Template の
インスタンスが利用するためのテンプレートの共有コピーを維持します。
これにより複数のサーバ環境でのメモリ消費が大きく減らされます。
例えば、私達のシステムの 1 つでは、テンプレート・キャッシュに 4MB を使い、
25 個の httpd プロセスを維持しています -
その結果 shared_cache はほぼ 100MB も節約しています。
もちろんスピードは通常のキャッシュで期待する程度からは少し落ちます。
もう 1 つの通常のキャッシュと shared_cashe との違いは、
shared_cache は CGI 環境で機能しますが、通常のキャッシュは
Apache/mod_perl のような永続する環境でのみ有効です。

=begin original

By default HTML::Template uses the IPC key 'TMPL' as a shared root
segment (0x4c504d54 in hex), but this can be changed by setting the
'ipc_key' new() parameter to another 4-character or integer key.
Other options can be used to affect the shared memory cache correspond
to IPC::SharedCache options - ipc_mode, ipc_segment_size and
ipc_max_size.  See L<IPC::SharedCache> for a description of how these
work - in most cases you shouldn't need to change them from the
defaults.

=end original

デフォルトでは HTML::Template は IPC キー 'TMPL' を共有ルートセグメント
(16 進数で 0x4c504d54) として使います。
しかしこれは、new() の 'ipc_key' パラメータに他の 4 文字または
整数値のキーを設定することにより変更することがきます。
共有メモリキャッシュに影響を与えるために使うことが
出来る他のオプションは IPC::SharedCache オプションに対応します -
ipc_mode, ipc_segment_size, ipc_max_sizeです。
これらがどのように機能するかは、L<IPC::SharedCache> をご覧下さい。
ほとんどの場合、それらをデフォルトから変更する必要はありません。

=begin original

For more information about the shared memory cache system used by
HTML::Template see L<IPC::SharedCache>.

=end original

HTML::Template で使われる共有メモリキャッシュシステムについての情報は
L<IPC::SharedCache> をご覧下さい。

=item *

=begin original

double_cache - if set to 1 the module will use a combination of
shared_cache and normal cache mode for the best possible caching.  Of
course, it also uses the most memory of all the cache modes.  All the
same ipc_* options that work with shared_cache apply to double_cache
as well.  By default double_cache is off.

=end original

double_cache - 1 に設定すると、モジュールは可能な限り
一番よいキャッシュのために、
shared_cache と通常の cache モードを組み合わせます。
もちろんすべてのキャッシュ・モードのなかでもっとも多くメモリを使います。
shared_cache に適用される、同じすべての ipc_* オプションが
double_cache にも機能します。デフォルトでは double_cache は 0 です。

=item *

=begin original

blind_cache - if set to 1 the module behaves exactly as with normal
caching but does not check to see if the file has changed on each
request.  This option should be used with caution, but could be of use
on high-load servers.  My tests show blind_cache performing only 1 to
2 percent faster than cache under mod_perl.

=end original

blind_cache - 1 に設定すると、通常のキャッシュと全く同じように動きますが、
リクエスト毎にファイルが変更されているかをチェックはしません。
このオプションは注意して使わなければなりませんが、
負荷の大きなサーバに使えるでしょう。
私のテストでは blind_cache は mod_perl での cache とくらべて、
1 から 2 パーセントしか速くなりませんでした。

=begin original

NOTE: Combining this option with shared_cache can result in stale
templates stuck permanently in shared memory!

=end original

注意: このオプションを shared_cache と組み合わせると、
共有メモリに古いテンプレートが永遠にたまってしまうかもしれません!

=item *

=begin original

file_cache - if set to 1 the module will store its cache in a file
using the Storable module.  It uses no additional memory, and my
simplistic testing shows that it yields a 50% performance advantage.
Like shared_cache, it will work in a CGI environment. Default is 0.

=end original

file_cache - 1 に設定すると、モジュールはキャッシュを
Storable モジュールを使ってファイルに置きます。
これは追加のメモリは消費せず、また私の簡単なテストによれば
パフォーマンスが 50% 向上します。
shared_cache と同様に、これは CGI 環境でも動作します。
デフォルトは 0 です。

=begin original

If you set this option you must set the "file_cache_dir" option.  See
below for details.

=end original

このオプションを設定した場合、"file_cache_dir" オプションも
設定する必要があります。
詳細については下記を参照して下さい。

=begin original

NOTE: Storable using flock() to ensure safe access to cache files.
Using file_cache on a system or filesystem (NFS) without flock()
support is dangerous.

=end original

Storable モジュールはキャッシュファイルに安全にアクセスするために
flock() を使います。
flock() に対応していないシステムやファイルシステム(NFS)で
file_cache を使うのは危険です。

=item *

=begin original

file_cache_dir - sets the directory where the module will store the
cache files if file_cache is enabled.  Your script will need write
permissions to this directory.  You'll also need to make sure the
sufficient space is available to store the cache files.

=end original

file_cache_dir - file_cache を有効にしたときにモジュールがキャッシュファイルを
保存するディレクトリを指定します。
このディレクトリに対する書き込み権限が必要です。
また、キャッシュファイルが保存できるだけの十分な空き容量も必要です。

=item *

=begin original

file_cache_dir_mode - sets the file mode for newly created file_cache
directories and subdirectories.  Defaults to 0700 for security but
this may be inconvenient if you do not have access to the account
running the webserver.

=end original

file_cache_dir_mode - file_cache ディレクトリやそのサブディレクトリに
新しく作られるディレクトリのファイルモードを設定します。
デフォルトはセキュリティのために 0700 になっていますが、これでは
ウェブサーバが動いているアカウントへのアクセス権がない場合には
不便かもしれません。

=item *

=begin original

double_file_cache - if set to 1 the module will use a combination of
file_cache and normal cache mode for the best possible caching.  The
file_cache_* options that work with file_cache apply to double_file_cache
as well.  By default double_file_cache is 0.

=end original

double_file_cache - 1 に設定すると、モジュールは file_cache と
通常のキャッシュを最良の状態にするために組み合わせます。
file_cache_* オプションは、double_file_cache で file_cache が
使われる場合にも動作します。
デフォルトでは double_file_cache は 0 です。

=back

=item Filesystem Options

(ファイルシステムオプション)

=over 4

=item *

=begin original

path - you can set this variable with a list of paths to search for
files specified with the "filename" option to new() and for files
included with the <TMPL_INCLUDE> tag.  This list is only consulted
when the filename is relative.  The HTML_TEMPLATE_ROOT environment
variable is always tried first if it exists.  Also, if
HTML_TEMPLATE_ROOT is set then an attempt will be made to prepend
HTML_TEMPLATE_ROOT onto paths in the path array.  In the case of a
<TMPL_INCLUDE> file, the path to the including file is also tried
before path is consulted.

Example:

=end original

path - new() への "filename" で指定されたファイルや <TMPL_INCLUDE> タグで
入れられるファイルを探すためのパスのリストを、
この変数に設定することが出来ます。
この変数はファイル名が相対であったときにのみ使われます。
HTML_TEMPLATE_ROOT 環境変数が存在すれば、常に最初にそれを試します。
また、HTML_TEMPLATE_ROOT が設定されている場合、
path 配列に入ったパスの前に HTML_TEMPLATE_ROOT をつけることも試みられます。
<TMPL_INCLUDE> ファイルの場合、インクルードファイルのパスも、
この path で指定したパスを利用する前に試されます。

例：

   my $template = HTML::Template->new( filename => 'file.tmpl',
                                       path => [ '/path/to/templates',
                                                 '/alternate/path'
                                               ]
                                      );

=begin original

NOTE: the paths in the path list must be expressed as UNIX paths,
separated by the forward-slash character ('/').

=end original

注意: path リストでのパスは UNIX パスのように、
スラッシュ文字('/')で区切られて、表現されなければなりません。

=item *

=begin original

search_path_on_include - if set to a true value the module will search
from the top of the array of paths specified by the path option on
every <TMPL_INCLUDE> and use the first matching template found.  The
normal behavior is to look only in the current directory for a
template to include.  Defaults to 0.

=end original

search_path_on_include - 真に設定されると、モジュールは
<TMPL_INCLUDE> が出てくる度に path オプションで指定された
パスの配列を最初から順番に探し、最初に一致したテンプレートが使われます。
通常の振る舞いは、テンプレートをインクルードするときに
カレントディレクトリだけを見ます。デフォルトは 0 です。

=back

=item Debugging Options

(デバッグオプション)

=over 4

=item *

=begin original

debug - if set to 1 the module will write random debugging information
to STDERR.  Defaults to 0.

=end original

debug - 1 に設定すると、モジュールはランダムなデバッグ情報を
STDERR に書きこみます。デフォルトは 0 です。

=item *

=begin original

stack_debug - if set to 1 the module will use Data::Dumper to print
out the contents of the parse_stack to STDERR.  Defaults to 0.

=end original

stack_debug - 1 に設定すると、モジュールは parse_stack の内容を
Data::Dumper を使って STDERR に出力します。デフォルトは 0 です。

=item *

=begin original

cache_debug - if set to 1 the module will send information on cache
loads, hits and misses to STDERR.  Defaults to 0.

=end original

cache_debug - 1 に設定すると、モジュールはキャッシュのロード、ヒット、
ミスについての情報を STDERR に送信します。デフォルトは 0 です。

=item *

=begin original

shared_cache_debug - if set to 1 the module will turn on the debug
option in IPC::SharedCache - see L<IPC::SharedCache> for
details. Defaults to 0.

=end original

shared_cache_debug - 1 に設定すると、
モジュールは IPC::SharedCache での debug オプションをオンにします。
詳細は L<IPC::SharedCache> をご覧下さい。デフォルトは 0 です。

=item *

=begin original

memory_debug - if set to 1 the module will send information on cache
memory usage to STDERR.  Requires the GTop module.  Defaults to 0.

=end original

memory_debug - 1 に設定すると、モジュールはキャッシュ・メモリ使用についての
情報を STDERR に送信します。GTop モジュールを必要とします。
デフォルトは 0 です。

=back

=item Miscellaneous Options

(その他のオプション)

=over 4

=item *

=begin original

associate - this option allows you to inherit the parameter values
from other objects.  The only requirement for the other object is that
it have a param() method that works like HTML::Template's param().  A
good candidate would be a CGI.pm query object.  Example:

=end original

associate - このオプションは他のオブジェクトからパラメータ値を
継承することを可能にします。
他のオブジェクトへの唯一の必要事項は、
HTML::Template のように機能する param() メソッドを持っていることです。
よい候補は CGI.pm の query オブジェクトです。例:

  my $query = new CGI;
  my $template = HTML::Template->new(filename => 'template.tmpl',
                                     associate => $query);

=begin original

Now, $template->output() will act as though 

=end original

そして $template->output() は以下のようになります:

  $template->param('FormField', $cgi->param('FormField'));

=begin original

had been specified for each key/value pair that would be provided by
the $cgi->param() method.  Parameters you set directly take precedence
over associated parameters.  

=end original

のように $cgi->param() メソッドにより提供されるであろう
キー/値のペアがそれぞれ指定されたかのように動きます。
直接指定したパラメータは associate されたパラメータよりも優先されます。

=begin original

You can specify multiple objects to associate by passing an anonymous
array to the associate option.  They are searched for parameters in
the order they appear:

=end original

associate オプションに無名配列を渡すことにより複数のオブジェクトを
関連付けるように指定することが出来ます。
それらは指定した順序でパラメータが検索されます:

  my $template = HTML::Template->new(filename => 'template.tmpl',
                                     associate => [$query, $other_obj]);

=begin original

The old associateCGI() call is still supported, but should be
considered obsolete.

=end original

古い associateCGI() 呼び出しはまだサポートされていますが、
もう古いものだと考えるべきです。

=begin original

NOTE: The parameter names are matched in a case-insensitve manner.  If
you have two parameters in a CGI object like 'NAME' and 'Name' one
will be chosen randomly by associate.  This behavior can be changed by
the following option.

=end original

注意: パラメータ名のマッチングでは大文字･小文字は区別されません。
もし CGI オブジェクトに 'NAME' と 'Name' のような 2 つのパラメータがあれば、
assosiate はでたらめにどちらかを選びます。
この振る舞いは以下のオプションで変えることができます。

=item *

=begin original

case_sensitive - setting this option to true causes HTML::Template to
treat template variable names case-sensitively.  The following example
would only set one parameter without the "case_sensitive" option:

=end original

case_sensitive - このオプションを真に設定すると、
HTML::Template はテンプレート変数の名前の大文字小文字を区別します。
以下の例は、"case_sensitive" オプションが設定されていない場合は
一つのパラメータしか設定しません:

  my $template = HTML::Template->new(filename => 'template.tmpl',
                                     case_sensitive => 1);
  $template->param(
    FieldA => 'foo',
    fIELDa => 'bar',
  );

=begin original

This option defaults to off.

=end original

このオプションのデフォルトはオフです。

=begin original

NOTE: with case_sensitive and loop_context_vars the special loop
variables are available in lower-case only.

=end original

注意: case_sensitive と loop_context_vars オプションが設定されて
いる場合、ループ専用変数は小文字でのみ利用可能です。

=item *

=begin original

loop_context_vars - when this parameter is set to true (it is false by
default) four loop context variables are made available inside a loop:
__first__, __last__, __inner__, __odd__.  They can be used with
<TMPL_IF>, <TMPL_UNLESS> and <TMPL_ELSE> to control how a loop is
output.  

=end original

loop_context_vars - このパラメータがtrueに設定されると(デフォルトは false）、
4 つのループ・コンテキスト変数、
__first__, __last__,  __inner__, __odd__ が作られ、
ループの中で使うことが出来ます。
これらは <TMPL_IF>, <TMPL_UNLESS>, <TMPL_ELSE> と一緒に使って、
ループがどのように出力されるかを制御することが出来ます。

=begin original

In addition to the above, a __counter__ var is also made available
when loop context variables are turned on.

=end original

上記に加えて、ループコンテキスト変数が有効な場合は、
__counter__ 変数も利用可能になります。

=begin original

Example:

=end original

例えば：

   <TMPL_LOOP NAME="FOO">
      <TMPL_IF NAME="__first__">
        This only outputs on the first pass.
      </TMPL_IF>

      <TMPL_IF NAME="__odd__">
        This outputs every other pass, on the odd passes.
      </TMPL_IF>

      <TMPL_UNLESS NAME="__odd__">
        This outputs every other pass, on the even passes.
      </TMPL_IF>

      <TMPL_IF NAME="__inner__">
        This outputs on passes that are neither first nor last.
      </TMPL_IF>

      This is pass number <TMPL_VAR NAME="__counter__">.

      <TMPL_IF NAME="__last__">
        This only outputs on the last pass.
      <TMPL_IF>
   </TMPL_LOOP>

=begin original

One use of this feature is to provide a "separator" similar in effect
to the perl function join().  Example:

=end original

この機能の使い道の 1 つは、perl 関数の join() と同じような効果で、
"区切り文字"を提供することです。例えば：

   <TMPL_LOOP FRUIT>
      <TMPL_IF __last__> and </TMPL_IF>
      <TMPL_VAR KIND><TMPL_UNLESS __last__>, <TMPL_ELSE>.</TMPL_UNLESS>
   </TMPL_LOOP>

=begin original

Would output (in a browser) something like:

=end original

これは (ブラウザでは) 以下のようになります：

  Apples, Oranges, Brains, Toes, and Kiwi.

=begin original

Given an appropriate param() call, of course.  NOTE: A loop with only
a single pass will get both __first__ and __last__ set to true, but
not __inner__.

=end original

もちろん適切な param() 呼び出しが与えられば、です。
注意: 1 回だけ通るループの場合、_first_ と _last_ は true に設定されますが、
_inner_ は設定されません。

=item *

=begin original

no_includes - set this option to 1 to disallow the <TMPL_INCLUDE> tag
in the template file.  This can be used to make opening untrusted
templates B<slightly> less dangerous.  Defaults to 0.

=end original

no_includes - 1 を設定すると、テンプレートファイル中の <TMPL_INCLUDE>
タグを無効にします。これにより信頼できないテンプレートの危険性を
B<多少>減らすことが出来ます。デフォルトは 0 です。

=item *

=begin original

max_includes - set this variable to determine the maximum depth that
includes can reach.  Set to 10 by default.  Including files to a depth
greater than this value causes an error message to be displayed.  Set
to 0 to disable this protection.

=end original

max_includes - インクルードが届くことが出来る最大の深さを決定するために
この変数を設定します。
デフォルトでは 10 に設定されています。
この値を超えた深さのファイルをインクルードするとエラーメッセージが発生し、
表示されます。0 にするとこの保護を無効にします。

=item *

=begin original

global_vars - normally variables declared outside a loop are not
available inside a loop.  This option makes <TMPL_VAR>s like global
variables in Perl - they have unlimited scope.  This option also
affects <TMPL_IF> and <TMPL_UNLESS>.

Example:

=end original

global_vars - 通常はループの外で宣言された変数はループの中では使えません。
このオプションは <TMPL_VAR> を Perl のグローバル変数のように -
制限されないスコープを持つ - します。
このオプションは <TMPL_IF> と <TMPL_UNLESS> にも影響を与えます。

例：

  This is a normal variable: <TMPL_VAR NORMAL>.<P>

  <TMPL_LOOP NAME=FROOT_LOOP>
     Here it is inside the loop: <TMPL_VAR NORMAL><P>
  </TMPL_LOOP>

=begin original

Normally this wouldn't work as expected, since <TMPL_VAR NORMAL>'s
value outside the loop is not available inside the loop.

=end original

通常これは、ループの外にある <TMPL_VAR NORMAL> の値が
ループの内側では使えないために、期待した通りには動きません。

=begin original

The global_vars option also allows you to access the values of an
enclosing loop within an inner loop.  For example, in this loop the
inner loop will have access to the value of OUTER_VAR in the correct
iteration:

=end original

global_vars オプションを使うと、外側のループの変数を
内側の変数で使えるようにもなります。
例えば、内側のループで正しい繰り返しで OUTER_VAR の値に
アクセスしたい場合は以下のようになります:

   <TMPL_LOOP OUTER_LOOP>
      OUTER: <TMPL_VAR OUTER_VAR>
        <TMPL_LOOP INNER_LOOP>
           INNER: <TMPL_VAR INNER_VAR>
           INSIDE OUT: <TMPL_VAR OUTER_VAR>
        </TMPL_LOOP>
   </TMPL_LOOP>

=item *

=begin original

filter - this option allows you to specify a filter for your template
files.  A filter is a subroutine that will be called after
HTML::Template reads your template file but before it starts parsing
template tags.

=end original

filter - このオプションはテンプレートファイルに対するフィルタを
指定します。フィルタは HTML::Template がテンプレートファイルを
読み込んだ後、テンプレートタグのパーズを開始する前に呼び出される
サブルーチンです。

=begin original

In the most simple usage, you simply assign a code reference to the
filter parameter.  This subroutine will recieve a single arguement - a
reference to a string containing the template file text.  Here is an
example that accepts templates with tags that look like "!!!ZAP_VAR
FOO!!!" and transforms them into HTML::Template tags:

=end original

もっとも単純な使い方は、filter オプションのパラメータとして
コードリファレンスを指定します。
このサブルーチンは 1 つの引数を取ります - これは
テンプレートファイルのテキストを含む文字列のリファレンスです。
以下は、"!!!ZAP_VAR FOO!!!" といった形のタグを含むテンプレートを
受け取り、HTML::Template のタグに変換する例です:

   my $filter = sub {
     my $text_ref = shift;
     $$text_ref =~ s/!!!ZAP_(.*?)!!!/<TMPL_$1>/g;
   };

   # open zap.tmpl using the above filter
   my $template = HTML::Template->new(filename => 'zap.tmpl',
                                      filter => $filter);

=begin original

More complicated usages are possible.  You can request that your
filter receieve the template text as an array of lines rather than as
a single scalar.  To do that you need to specify your filter using a
hash-ref.  In this form you specify the filter using the "sub" key and
the desired argument format using the "format" key.  The available
formats are "scalar" and "array".  Using the "array" format will incur
a performance penalty but may be more convenient in some situations.

=end original

もっと複雑な使い方も可能です。フィルタが単一のスカラではなく、
行単位の配列として受け取ることも出来ます。
そのためにはフィルタをハッシュリファレンスを使って指定する必要があります。
この形ではフィルタを "sub" キーで、望む引数の形を "format" キーで
指定します。format に "array" を使うとパフォーマンスが
悪化しますが、状況によってはより便利です。

   my $template = HTML::Template->new(filename => 'zap.tmpl',
                                      filter => { sub => $filter,
                                                  format => 'array' });

=begin original

You may also have multiple filters.  This allows simple filters to be
combined for more elaborate functionality.  To do this you specify an
array of filters.  The filters are applied in the order they are
specified.

=end original

複数のフィルタを使うことも出来ます。
これにより、単純なフィルタを組み合わせてより複雑な機能を持たせることが
できます。フィルタは指定された順番で適用されます。

   my $template = HTML::Template->new(filename => 'zap.tmpl',
                                      filter => [ 
                                           { sub => \&decompress,
                                             format => 'scalar' },
                                           { sub => \&remove_spaces,
                                             format => 'array' }
                                        ]);

=begin original

The specified filters will be called for any TMPL_INCLUDEed files just
as they are for the main template file.

=end original

指定されたフィルタは TMPL_INCLUDE でファイルが読み込まれる度に
メインのテンプレートファイルと同様に適用されます。

=back

=back 4

=head2 param()

=begin original

param() can be called in a number of ways

=end original

param() はいくつかの方法で呼び出されます。

=begin original

1) To return a list of parameters in the template : 

=end original

1) テンプレートでのパラメータのリストを返す:

   my @parameter_names = $self->param();
   

=begin original

2) To return the value set to a param : 

=end original

2) パラメータに設定された値を返す:

   my $value = $self->param('PARAM');

=begin original

3) To set the value of a parameter :

=end original

3) パラメータに値を設定する:

      # For simple TMPL_VARs:
      $self->param(PARAM => 'value');

      # with a subroutine reference that gets called to get the value
      # of the scalar.  The sub will recieve the template object as a
      # parameter.
      $self->param(PARAM => sub { return 'value' });   

      # And TMPL_LOOPs:
      $self->param(LOOP_PARAM => 
                   [ 
                    { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
                    { PARAM => VALUE_FOR_SECOND_PASS, ... } 
                    ...
                   ]
                  );

=begin original

4) To set the value of a a number of parameters :

=end original

4) 複数のパラメータを設定する:

     # For simple TMPL_VARs:
     $self->param(PARAM => 'value', 
                  PARAM2 => 'value'
                 );

      # And with some TMPL_LOOPs:
      $self->param(PARAM => 'value', 
                   PARAM2 => 'value',
                   LOOP_PARAM => 
                   [ 
                    { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
                    { PARAM => VALUE_FOR_SECOND_PASS, ... } 
                    ...
                   ],
                   ANOTHER_LOOP_PARAM => 
                   [ 
                    { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
                    { PARAM => VALUE_FOR_SECOND_PASS, ... } 
                    ...
                   ]
                  );

=begin original

5) To set the value of a a number of parameters using a hash-ref :

=end original

5) ハッシュ・リファレンスを使って複数のパラメータを設定:

      $self->param(
                   { 
                      PARAM => 'value', 
                      PARAM2 => 'value',
                      LOOP_PARAM => 
                      [ 
                        { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
                        { PARAM => VALUE_FOR_SECOND_PASS, ... } 
                        ...
                      ],
                      ANOTHER_LOOP_PARAM => 
                      [ 
                        { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
                        { PARAM => VALUE_FOR_SECOND_PASS, ... } 
                        ...
                      ]
                    }
                   );

=pod

=head2 clear_params()

=begin original

Sets all the parameters to undef.  Useful internally, if nowhere else!

=end original

すべてのパラメータをundefに設定します。
他では使えなくても、内部的には便利です!

=head2 output()

=begin original

output() returns the final result of the template.  In most situations
you'll want to print this, like:

=end original

output() はテンプレートの最終結果を返します。
ほとんどの場合、以下のようにこれを出力したいでしょう:

   print $template->output();

=begin original

When output is called each occurrence of <TMPL_VAR NAME=name> is
replaced with the value assigned to "name" via param().  If a named
parameter is unset it is simply replaced with ''.  <TMPL_LOOPS> are
evaluated once per parameter set, accumlating output on each pass.

=end original

output が呼ばれると、<TMPL_VAR NAME=name> のそれぞれは param() を通して
"name" に代入された値で置き換えられます。
もし名前付きのパラメータの設定をはずされたら、
単に''で置きかえられます。
<TMPL_LOOPS> はパラメータセット毎に 1 度評価され、
それぞれの出力を蓄積します。

=begin original

Calling output() is guaranteed not to change the state of the
Template object, in case you were wondering.  This property is mostly
important for the internal implementation of loops.

=end original

気にしているかもしれないので言っておきますが、
output() を呼ぶことは Template オブジェクトの状態を変更しないことを
保証されています。この属性はループの内部での実装にとってとても重要です。

=begin original

You may optionally supply a filehandle to print to automatically as
the template is generated.  This may improve performance and lower
memory consumption.  Example:

=end original

オプションとして、テンプレートが生成されたときに自動的に出力する
ファイルハンドルを指定することもできます。
これによりパフォーマンスが向上し、メモリ消費が減ります。例:

   $template->output(print_to => *STDOUT);

=begin original

The return value is undefined when using the "print_to" option.

=end original

"print_to" オプションが使われた場合には、返り値は未定義値です。

=pod

=head2 query()

=begin original

This method allow you to get information about the template structure.
It can be called in a number of ways.  The simplest usage of query is
simply to check whether a parameter name exists in the template, using
the C<name> option:

=end original

このメソッドはテンプレート構造についての情報を取得することを可能にします。
いくつかの方法で呼ぶことができます。
query の最も簡単な使い方は、name オプションを使って、
テンプレートにパラメータ名があるかをチェックすることです:

  if ($template->query(name => 'foo')) {
    # do something if a varaible of any type 
    # named FOO is in the template
  }

=begin original

This same usage returns the type of the parameter.  The type is the
same as the tag minus the leading 'TMPL_'.  So, for example, a
TMPL_VAR parameter returns 'VAR' from query().

=end original

これと同じ使い方はパラメータのタイプを返します。
タイプはタグから頭の 'TMPL_' を引いたものと同じです。
例えば、TMPL_VAR パラメータは query() からは 'VAR' を返します。

  if ($template->query(name => 'foo') eq 'VAR') {
    # do something if FOO exists and is a TMPL_VAR
  }

=begin original

Note that the variables associated with TMPL_IFs and TMPL_UNLESSs will
be identified as 'VAR' unless they are also used in a TMPL_LOOP, in
which case they will return 'LOOP'.

=end original

TMPL_IF と TMPL_UNLESS に結び付けられている変数は
TMPL_LOOP で使われていない限り、'VAR' で示されます。
TMPL_LOOP で使われていれば、'LOOP' を返します。

=begin original

C<query()> also allows you to get a list of parameters inside a loop
(and inside loops inside loops).  Example loop:

=end original

query() はループの内側(さらにループの内側のループの内側)の
パラメータのリストを取得することも可能にします。例えば:

   <TMPL_LOOP NAME="EXAMPLE_LOOP">
     <TMPL_VAR NAME="BEE">
     <TMPL_VAR NAME="BOP">
     <TMPL_LOOP NAME="EXAMPLE_INNER_LOOP">
       <TMPL_VAR NAME="INNER_BEE">
       <TMPL_VAR NAME="INNER_BOP">
     </TMPL_LOOP>
   </TMPL_LOOP>

=begin original

And some query calls:

=end original

そしていくつかの query の呼び出し:

  # returns 'LOOP'
  $type = $template->query(name => 'EXAMPLE_LOOP');
    
  # returns ('bop', 'bee', 'example_inner_loop')
  @param_names = $template->query(loop => 'EXAMPLE_LOOP');

  # both return 'VAR'
  $type = $template->query(name => ['EXAMPLE_LOOP', 'BEE']);
  $type = $template->query(name => ['EXAMPLE_LOOP', 'BOP']);

  # and this one returns 'LOOP'
  $type = $template->query(name => ['EXAMPLE_LOOP', 
                                    'EXAMPLE_INNER_LOOP']);
  
  # and finally, this returns ('inner_bee', 'inner_bop')
  @inner_param_names = $template->query(loop => ['EXAMPLE_LOOP',
                                                 'EXAMPLE_INNER_LOOP']);

  # for non existent parameter names you get undef
  # this returns undef.
  $type = $template->query(name => 'DWEAZLE_ZAPPA');

  # calling loop on a non-loop parameter name will cause an error.
  # this dies:
  $type = $template->query(loop => 'DWEAZLE_ZAPPA');

=begin original

As you can see above the C<loop> option returns a list of parameter
names and both C<name> and C<loop> take array refs in order to refer
to parameters inside loops.  It is an error to use C<loop> with a
parameter that is not a loop.

=end original

上記のように、C<loop> オプションはパラメータ名のリストを返し、
C<name> も C<loop> もループの内側のパラメータを参照するために
配列リファレンスを取ります。
C<loop> でないパラメータで C<loop> を使うとエラーになります。

=begin original

Note that all the names are returned in lowercase and the types are
uppercase.

=end original

返されるすべての名前は小文字で、タイプは大文字であることに注意してください。

=begin original

Just like C<param()>, C<query()> with no arguements returns all the
parameter names in the template at the top level.

=end original

C<param()>、C<query()>と同じように、引数を指定しないと、
テンプレートでのトップ・レベルのすべてのパラメータ名を返します。

=head1 FREQUENTLY ASKED QUESTIONS

=begin original

In the interest of greater understanding I've started a FAQ section of
the perldocs.  Please look in here before you send me email.

=end original

よりよく理解されるために perldoc の FAQ セクションを始めました。
私に email を送る前に、どうかここをご覧下さい。

=over 4

=item 1

=begin original

Q: Is there a place to go to discuss HTML::Template and/or get help?

=end original

Q: HTML::Template について議論したり、助けを得るための場所はありますか？

=begin original

A: There's a mailing-list for discussing HTML::Template at
html-template-users@lists.sourceforge.net.  To join:

=end original

HTML::Template について議論するためのメーリングリストが
html-template-users@lists.sourceforge.net にあります。
参加するためには、以下のページを参照して下さい:

   http://lists.sourceforge.net/lists/listinfo/html-template-users

=begin original

If you just want to get email when new releases are available you can
join the announcements mailing-list here:

=end original

新しいリリースが出たのを知りたいだけなら、アナウンス用の
メーリングリストもあります:

   http://lists.sourceforge.net/lists/listinfo/html-template-announce

=item 2

=begin original

Q: Is there a searchable archive for the mailing-list?

=end original

Q; 検索可能なメーリングリストのアーカイブはありますか?

=begin original

A: Yes, you can find an archive of the SourceForge list here:

=end original

はい、SourceForge メーリングリストのアーカイブが以下の場所にあります:

  http://www.geocrawler.com/lists/3/SourceForge/23294/0/

=begin original

For an archive of the old vm.com list, setup by Sean P. Scanlon, see:

=end original

古い vm.com 時代のメーリングリストのアーカイブは、
Sean P. Scanlon が設定したものが以下の場所にあります:

   http://bluedot.net/mail/archive/

=item 3

=begin original

Q: I want support for <TMPL_XXX>!  How about it?

=end original

Q: <TMPL_XXX> に対応してほしいんです!どうすればいいんでしょう?

=begin original

A: Maybe.  I definitely encourage people to discuss their ideas for
HTML::Template on the mailing list.  Please be ready to explain to me
how the new tag fits in with HTML::Template's mission to provide a
fast, lightweight system for using HTML templates.

=end original

たぶん。私はメーリング・リストで HTML::Template のためのアイデアについて
議論することを皆さんに勧めます。新しいタグが、HTML テンプレートを
使用するための高速で、軽量なシステムを提供するという
HTML::Template の使命にどのようにフィットするのかを
説明する準備をしておいてください。

=begin original

NOTE: Offering to program said addition and provide it in the form of
a patch to the most recent version of HTML::Template will definitely
have a softening effect on potential opponents!

=end original

注意: その機能をプログラムして、最新バージョンの HTML::Template への
パッチの形で提供すれば、間違い無く潜在的な反対者を弱くさせるでしょう!

=item 4

=begin original

Q: I found a bug, can you fix it?

=end original

Q: バグを見つけました。修正してもらえますか?

=begin original

A: That depends.  Did you send me the VERSION of HTML::Template, a test
script and a test template?  If so, then almost certainly.

=end original

場合によります。HTML::Templateの バージョン、テスト・スクリプトと
テスト・テンプレートを送りましたか?そうであれば、たぶん間違い無いでしょう。

=begin original

If you're feeling really adventurous, HTML::Template has a publically
available CVS server.  See below for more information in the PUBLIC
CVS SERVER section.

=end original

もしあなたが本当に大胆であれば、HTML::Template はパブリックに利用可能な
CVS サーバを持っています。詳細についてはパブリックな CVS サーバ・セクションを
ご覧下さい。

=item 5

=begin original

Q: <TMPL_VAR>s from the main template aren't working inside a
<TMPL_LOOP>!  Why?

=end original

Q: メイン・テンプレートからの <TMPL_VAR> が <TMPL_LOOP> の内側で機能しません!
なぜ?

=begin original

A: This is the intended behavior.  <TMPL_LOOP> introduces a separate
scope for <TMPL_VAR>s much like a subroutine call in Perl introduces a
separate scope for "my" variables.

=end original

これは予定されている動きです。<TMPL_LOOP> は、Perl でのサブルーチン呼び出しが
"my" 変数のために別のスコープを導入するのと同じように、
<TMPL_VAR> のために別のスコープを導入します。

=begin original

If you want your <TMPL_VAR>s to be global you can set the
'global_vars' option when you call new().  See above for documentation
of the 'global_vars' new() option.

=end original

<TMPL_VAR> をグローバルにしたければ、new() を呼び出すときに
'global_vars' を設定することが出来ます。
new() の 'global_vars' オプションのドキュメントについては上記をご覧下さい。

=item 6

=begin original

Q: Why do you use /[Tt]/ instead of /t/i?  It's so ugly!

=end original

Q: なぜ /t/i ではなく /[Tt]/ を使うのですか?醜いです!

=begin original

A: Simple - the case-insensitive match switch is very inefficient.
According to _Mastering_Regular_Expressions_ from O'Reilly Press,
/[Tt]/ is faster and more space efficient than /t/i - by as much as
double against long strings.  //i essentially does a lc() on the
string and keeps a temporary copy in memory.

=end original

A: 簡単です- 大文字小文字を無視したマッチのスイッチは効率的ではありません。
"Mastering Regular Expressions"（詳説　正規表現）O'Reilly Press によると、
/[Tt]/ は /t/i にくらべてより速く、よりスペースを有効に使います -
文字列の長さの倍程度。
//i は基本的に文字列に lc() をおこない、
一時的なコピーをメモリに保持します。

=begin original

When this changes, and it is in the 5.6 development series, I will
gladly use //i.  Believe me, I realize [Tt] is hideously ugly.

=end original

これが変更されたら、そしてそれが 5.6 開発シリーズに入ったら、
私は喜んで //i を使います。信じてください、[Tt] がぞっとするほど
醜いことは私もわかっています。

=item 7

=begin original

Q: How can I pre-load my templates using cache-mode and mod_perl?

=end original

Q: cache モードと mod_perl を使ってテンプレートを予め
ロードするにはどのようにすればできますか?

=begin original

A: Add something like this to your startup.pl:

=end original

A: startup.plに以下のようなものを追加します：

   use HTML::Template;
   use File::Find;

   print STDERR "Pre-loading HTML Templates...\n";
   find(
        sub {
          return unless /\.tmpl$/;
          HTML::Template->new(
                              filename => "$File::Find::dir/$_",
                              cache => 1,
                             );
        },
        '/path/to/templates',
        '/another/path/to/templates/'
      );

=begin original

Note that you'll need to modify the "return unless" line to specify
the extension you use for your template files - I use .tmpl, as you
can see.  You'll also need to specify the path to your template files.

=end original

あなたがあなたのテンプレートに使用している拡張子を指定するように
"return unless" 行を変更する必要があることに注意してください。
ご存知でしょうが、私は '.tmpl' を使っています。
また、あなたのテンプレートファイルへのパスも設定する必要があるでしょう。

=begin original

One potential problem: the "/path/to/templates/" must be EXACTLY the
same path you use when you call HTML::Template->new().  Otherwise the
cache won't know they're the same file and will load a new copy -
instead getting a speed increase, you'll double your memory usage.  To
find out if this is happening set cache_debug => 1 in your application
code and look for "CACHE MISS" messages in the logs.

=end original

1つの潜在的な問題: "/path/to/templates"は、HTML::Template->new() を
呼ぶときに使うのとまったく同じパスでなければいけません。
そうでなければ、cache は同じファイルであることがわからず、
新しいコピーをロードします。
スピードはあがらずに、代りに、2 倍メモリを使用します。
これが起こっているかどうかを調べるには、
アプリケーションのなかで cache_debug =>1 を設定し、
ログに "CACHE MISS" メッセージが無いかを調べます。

=item 8

=begin original

Q: What characters are allowed in TMPL_* NAMEs?

=end original

A: TMPL_* NAMEにはどんな文字が許されますか?

=begin original

A: Numbers, letters, '.', '/', '+', '-' and '_'.

=end original

A: 数字、英字、 '.', '/', '+', '-',  '_' です。

=item 9

=begin original

Q: How can I execute a program from inside my template?  

=end original

Q: どうすればテンプレートの中からプログラムを実行できますか?

=begin original

A: Short answer: you can't.  Longer answer: you shouldn't since this
violates the fundamental concept behind HTML::Template - that design
and code should be seperate.

=end original

A: 短く言えば: それはできません。
長く答えると、HTML::Templateの背後にある基本的な概念 -
デザインとプログラムは分けるべき - に反するのでするべきではありません。

=begin original

But, inevitably some people still want to do it.  If that describes
you then you should take a look at
L<HTML::Template::Expr|HTML::Template::Expr>.  Using
HTML::Template::Expr it should be easy to write a run_program()
function.  Then you can do awful stuff like:

=end original

しかし避けられないことに、人によってはまだそれをすることを欲します。
これがあなたのことなら、L<HTML::Template::Expr|HTML::Template::Expr> を
見るべきでしょう。
HTML::Template::Expr を使うと、run_program() 関数を簡単に書くことができるでしょう。
これで以下のようなおぞましいことができるようになります:

  <tmpl_var expr="run_program('foo.pl')">

Just, please, don't tell me about it.  I'm feeling guilty enough just
for writing HTML::Template::Expr in the first place.

=item 10

Q: Can I get a copy of these docs in Japanese?

A: Yes you can.  See Kawai Takanori's translation at:

   http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm

=item 11

Q: What's the best way to create a <select> form element using
HTML::Template?

A: There is much disagreement on this issue.  My personal preference
is to use CGI.pm's excellent popup_menu() and scrolling_list()
functions to fill in a single <tmpl_var select_foo> variable.  

To some people this smacks of mixing HTML and code in a way that they
hoped HTML::Template would help them avoid.  To them I'd say that HTML
is a violation of the principle of separating design from programming.
There's no clear separation between the programmatic elements of the
<form> tags and the layout of the <form> tags.  You'll have to draw
the line somewhere - clearly the designer can't be entirely in charge
of form creation.

It's a balancing act and you have to weigh the pros and cons on each side.
It is certainly possible to produce a <select> element entirely inside the
template.  What you end up with is a rat's nest of loops and conditionals.
Alternately you can give up a certain amount of flexibility in return for
vastly simplifying your templates.  I generally choose the latter.

Another option is to investigate HTML::FillInForm which some have
reported success using to solve this problem.

=back

=head1 BUGS

=begin original

I am aware of no bugs - if you find one, join the mailing list and
tell us about it.  You can join the HTML::Template mailing-list by
visiting:

=end original

私はバグについて何も気がついていません - もし見つけたら
メーリング・リストに参加して、それを伝えてください。
HTML::Template メーリング・リストには以下のページから参加できます:

  http://lists.sourceforge.net/lists/listinfo/html-template-users

=begin original

Of course, you can still email me directly (sam@tregar.com) with bugs,
but I reserve the right to forward bug reports to the mailing list.

=end original

もちろんバグについて私に直接メールする(sam@tregar.com)こともできます。
しかし私は言われたバグレポートを転送する権利を保持しています。

=begin original

When submitting bug reports, be sure to include full details,
including the VERSION of the module, a test script and a test template
demonstrating the problem!

=end original

バグ・レポートを送信するときには問題を証明する、モジュールの VERSION、
テスト・スクリプト、そしてテスト・テンプレートを間違い無く入れてください!

=begin original

If you're feeling really adventurous, HTML::Template has a publically
available CVS server.  See below for more information in the PUBLIC
CVS SERVER section.

=end original

もしあなたが本当に大胆であれば、HTML::Template は
パブリックに利用可能な CVS サーバを持っています。
詳細についてはパブリックな CVS サーバ・セクションをご覧下さい。

=head1 CREDITS

=begin original

This module was the brain child of my boss, Jesse Erlbaum
( jesse@vm.com ) at Vanguard Media ( http://vm.com ) .  The most original
idea in this module - the <TMPL_LOOP> - was entirely his.

=end original

このモジュールは Vanguard Media での私の上司 Jesse Erlbaum (jesse@vm.com) の
頭脳の産物です。
このモジュールでの最大のオリジナルのアイデア - <TMPL_LOOP> - は
完全に彼のものです。

=begin original

Fixes, Bug Reports, Optimizations and Ideas have been generously
provided by:

=end original

以下の方々からは修正、バグ・レポート、最適化そしてアイデアを
惜しみなくいただきました:

   Richard Chen
   Mike Blazer
   Adriano Nagelschmidt Rodrigues
   Andrej Mikus
   Ilya Obshadko
   Kevin Puetz
   Steve Reppucci
   Richard Dice
   Tom Hukins
   Eric Zylberstejn
   David Glasser
   Peter Marelas
   James William Carlson
   Frank D. Cringle
   Winfried Koenig
   Matthew Wickline
   Doug Steinwand
   Drew Taylor
   Tobias Brox
   Michael Lloyd
   Simran Gambhir
   Chris Houser <chouser@bluweb.com>
   Larry Moore
   Todd Larason
   Jody Biggs
   T.J. Mather
   Martin Schroth
   Dave Wolfe
   uchum
   Kawai Takanori
   Peter Guelich
   Chris Nokleberg
   Ralph Corderoy
   William Ward
   Ade Olonoh
   Mark Stosberg
   Lance Thomas
   Roland Giersig
   Jere Julian
   Peter Leonard
   Kenny Smith
   Sean P. Scanlon
   Martin Pfeffer
   David Ferrance
   Gyepi Sam  
   Darren Chamberlain

=begin original

Thanks!

=end original

どうもありがとう!

=head1 WEBSITE

You can find information about HTML::Template and other related modules at:

   http://html-template.sourceforge.net

=head1 PUBLIC CVS SERVER

=begin original

HTML::Template now has a publicly accessible CVS server provided by
SourceForge (www.sourceforge.net).  You can access it by going to
http://sourceforge.net/cvs/?group_id=1075.  Give it a try!

=end original

HTML::Template は SourceForge (www.sourceforge.net)によって提供される
パブリックにアクセスすることができる CVS サーバを持っています。
それには http://sourceforge.net/cvs/?group_id=1075 にいくことにより
アクセスできます。トライしてみてください!

=head1 AUTHOR

Sam Tregar, sam@tregar.com

=head1 LICENSE

  HTML::Template : A module for using HTML Templates with Perl
  Copyright (C) 2000-2002 Sam Tregar (sam@tregar.com)

  This module is free software; you can redistribute it and/or modify it
  under the terms of either:

  a) the GNU General Public License as published by the Free Software
  Foundation; either version 1, or (at your option) any later version,
  
  or

  b) the "Artistic License" which comes with this module.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
  the GNU General Public License or the Artistic License for more details.

  You should have received a copy of the Artistic License with this
  module, in the file ARTISTIC.  If not, I'll be glad to provide one.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
  USA

