=head1 名前

File::Tail - 継続的に更新されるファイルを読み込むためのPerl拡張

=head1 概要

  use File::Tail;
  $file=File::Tail->new("/some/log/file");
  while (defined($line=$file->read)) {
      print "$line";
  }

  use File::Tail;
  $file=File::Tail->new(name=>$name, maxinterval=>300, adjustafter=>7);
  while (defined($line=$file->read)) {
      print "$line";
  }

あるいはtieを使うこともできます(追加のパラメータをnameで渡したり、
$refを使って設定することができます):

    use File::Tail;
    my $ref=tie *FH,"File::Tail",(name=>$name);
    while (<FH>) {
        print "$_";
    }
}

上記のスクリプトが絶対に終了しないことに注意してください。そのファイルに
書き込まれるものがなければ、単にブロックするだけです。

更なる概要がファイルlogwatchに入っています。それはこの
ディレストリビューションに含まれています。

注意: Select機能はバージョン0.9で追加されています。そしてそれは
全てのルーチンをいくらか再起動させることを必要とします。
何かおかしなことがあったら***どうか***私に教えてください。

ファイルselect_demoの中に、selectの2つの使い方が入っています。それは
このディストリビューションに入っています。

=head1 説明

File::Tailの基本的な目的は、書かれている途中にログ・ファイルを読み込み、
解析することです。Tobias OetikerのMRTGのようなツールで
ログを出力するプロセスを管理するのに、特に便利です。

このモジュールはトラフィックのあまりないファイルに対する"busy-wait"は
それほど熱心に対応しません。それはいつもファイルから新しいデータを
読み込み、新しい行の数を数え、そしてその前にファイルに最後のデータが書かれて
から経過した時間によりその数を割ります。それは新しいデータが書かれるまでの
平均時間と考えることができます。読み込む新しいデータがないときには、
C<File::Tail>は何秒かsleepします。その後は、待ち時間は動的に再計算
されます。C<File::Tail>はC<maxinterval>により設定された秒数以上には
sleepしないことに注意してください。

ファイルがしばらく変更されなければ、C<File::Tail>はうさんくさいと思い、
ファイルが切り縮められてないか、移動され再作成されていないかチェックしはじめます。
もしそのようなことがあると、C<File::Tail>はだまってファイルを再オープンし、
読み込みを続けます。再オープンのとき、起きることに影響をあたえる唯一の方法は
reset_tailパラメータを設定すること(下記参照)です。この結果、スクリプトは
ログファイルが切り換えられたときに気が付く必要がありません。それらは静かに
作業を続けます。

利用されているsleepとtimeがTime::HiResからのものであることに注意してください。
そのためこのモジュールは、sleepする時間が1秒より小さくても、うまく動作する
はずです。

(中に入っている)logwatchスクリプトはメソッド呼び出しのいくつかの方法を
デモしています。

=head1 コンストラクタ

=head2 new ([ ARGS ]) 

C<File::Tail>を作成します。パラメータを1つしかもっていなければ、
それはファイル名だと想定されます。オープンが失敗すると、モジュールは
croakをおこないます。私は現在のところ$!を設定し、undefを返す方法を
探しているところです。

newにはいくつかのパラメータを渡すことができます:

=over 4

=item name

オープンするファイルの名前。ファイルは読み込み用でオープンされます。
これはパイプや端末ではなく、通常のファイルでなければなりません(つまり
seekできなければいけません)。

=item maxinterval

sleepすることに費やされる(実数での)最大秒数。デフォルトは60で、
C<File::Tail>はファイルをチェックすることなく60秒以上sleepすることは
ないことを意味します。

=item interval

ファイルが最初にチェックされるまでにsleepすることに費やされる
初期の(実数での)秒数。デフォルトは10で、C<File::Tail>は10秒sleepしてから、
ファイルに何行、新しい行数が現れたのかを判断します。

=item adjustafter

間隔を調整する前に、C<File::Tail>が現在の間隔で待つC<回数>。
デフォルトは10。

=item resetafter

C<File::Tail>がファイルはクローズされ、再オープンされたかもしれないと
判断した最後の変更の後の秒数。デフォルトはadjustafter*maxinterval。

=item maxbuf

内部バッファの最大サイズ。File::Tailが突然、ファイルに大量の情報を
見つけたとき(例えばretryパラメータが極まれにしかチェックしないように
設定され、ファイルが切り換えられたときなど)、File::Tailはあまりにも
大量のファイルをメモリに読み込んでしまうこともあります。これは
File::Tailのバッファの最大サイズを設定します。

デフォルトの値は16384 (バイト)です。

File::Tailは内部バッファを処理する以上のことをする必要があるので、
内部バッファが大きいと(メモリ使用量が増えるにつれて)パフォーマンスが
悪くなってしまうかもしれません、

=item nowait

読み込みのさいブロックしません。しかし読むものがなければ空文字列を
返します。何をしているのかわからないのであれば、これを使わないように。
ループのなかでこれを使うのならば、あなたは何を行っているのかわかって
いません。複数のファイルから最後を読みたいのであれば、selectを使って
ください。


=item ignore_nonexistant

最初にオープンしたり、再オープンするときに、ファイルがなくても
文句を言いません。(最後のデータが見つからないために、
resetafterの秒数が経過した後、再オープンされるかもしれません。)

=item tail

最初に開始されると、読み込まれ、ファイルからC<n>行が返されます。
C<n>が0であれば、ファイルの終わりから始めます。C<n>がマイナスであれば、
ファイル全体を返します。

デフォルトはC<0>です。

=item reset_tail

tailと同じ。しかしresetの後に適用されます(つまりファイルが
自動的にクローズされ再オープンされた後)。デフォルトは
C<-1>。つまり最初にそれをチェックしたときに、ファイルに
あるすべての情報は何も飛ばしません。

他のことがしたいんでしょうか？以下のように切り換えられる
ファイルを見たことがあります:

   grep -v lastmonth log >newlog 
   mv log archive/lastmonth 
   mv newlog log 
   kill -HUP logger 


明らかに、これが発生し、reset_tailがc<-1>に設定されていると、
突然、大量の行-既に見たことのある行-を取得することになります。
そのため、この場合には、おそらく小さな正の数か、C<0>に設定
するべきでしょう。

=item debug

File::Tailの内部的な動作についてより多くのことを見たければ、
0以外の値に設定してください。そうでなければ便利ではありません。

=item errmode

Net::Telnetのメソッドを見本に、これによりエラーをどのように扱うかを
指定することができます。パラメータはエラー文字列をパラメータとして
持つ、コード・リファレンス、最初のパラメータがコード・リファレンス、
その他のパラメータがそのハンドラー・サブルーチンに渡されるという配列、
あるいは以下の単語のいずれかにすることができます:

return  - すべてのエラーを無視(単にerrmsgにエラーメッセージを設定)。
warn    - エラー・メッセージは出力するが継続
die     - エラーメッセージを出し、終了

デフォルトはdieです。

=back 

=head1 メソッド

=head2 read

C<read>は入力ファイルから1行返します。準備が整っている行がなければ、
それが存在するようになるまでブロックします。

=head2 select

C<select>は、通常のファイルハンドルとFile::Tailのファイルハンドルを
同時に待つことができるようにすることを目的にしています。もちろん
単に、一度に複数のFile::Tailのファイルハンドルから読み込むために使う
こともできます。

使用例としては、スクリプトselect_demoをご覧ください。

基本的に、単純に通常のselectのように、rbits、wbits、ebits、timeoutの
フィールドをつけて呼び出して下さい。しかし任意の数のFile::Tailオブジェクト
(File::Tail ファイルハンドルではありません!)を末尾につけることができます。

これをするとFile::Tailのselectは通常のselectをエミュレートします。
ただし2点の例外があります:

a) パラメータの中に入力があれば、(つまり通常のファイルハンドル)
あるいはFile::Tailsを返します。

b) C<($nfound, $timeleft)>に加えて、読み込むための準備ができている
File::Tailオブジェクトのリストが入っている配列も返します。C<$nfound>は
読み込むファイル・ハンドルの正しい数が入っています(つまり通常とFile::Tails
の両方)

一度、selectが戻ると、どのFile::Tailオブジェクトの入力準備ができているかを
判定したいときには、selectから返されたオブジェクトのリストを使ったり、
$object->predictで個々のオブジェクトを使ってチェックすることができます。
これはハンドルが入力を期待できる時間の合計(小数の秒数)を返します。
入力待ちがあれば0を返します。返された秒数が経過した後、入力待ちがあるという
保証は何もありません。しかしながら、File::Tailはその時間が経過するまで
そのファイルに何も入出力をおこないません。

また個別のpredictを呼び出すことにより、どのファイルが入力準備ができているかを
判定するのであれば、seletが返されてから、チェックするまでの時間の間に
1つあるいは複数のFile::Tailのファイルが準備できてしまうかもしれないので、
C<$nfound>の値は正しくないことに注意してください。

=head1 TO BE DONE

0.95-1.0で計画中:"行"を分割するために\nのの代わりに$/を使うようにする
(これによりwtmp型のファイルを読み込むことが可能になるはずです)。

=head1 作者(=AUTHOR)

Matija Grabnar, matija.grabnar@arnes.si

=head1 SEE ALSO

perl(1), tail (1), 
MRTG (http://ee-staff.ethz.ch/~oetiker/webtools/mrtg/mrtg.html)

=head1 翻訳者

川合孝典(GCD00051@nifty.ne.jp)
